@page "/flows"
@page "/flows/{FlowId}"
@rendermode InteractiveServer
@inject ConfigService ConfigService
@inject NodePluginRegistry NodeRegistry
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime
@inject RealtimeDataService RealtimeData
@implements IDisposable

<PageTitle>Flows - DataForeman</PageTitle>

<div class="page-container">
    @if (string.IsNullOrEmpty(FlowId))
    {
        <!-- Flow List View -->
        <div class="page-toolbar">
            <h2><i class="fa-solid fa-diagram-project"></i> Flows</h2>
            <div class="toolbar-actions">
                <SfButton CssClass="e-primary" IconCss="fa-solid fa-plus" @onclick="CreateNewFlow">New Flow</SfButton>
            </div>
        </div>
        
        @if (!ConfigService.Flows.Any())
        {
            <div class="empty-state">
                <i class="fa-solid fa-diagram-project"></i>
                <span>No flows configured</span>
                <SfButton CssClass="e-primary e-small" @onclick="CreateNewFlow">Create your first flow</SfButton>
            </div>
        }
        else
        {
            <SfGrid DataSource="@FlowsList" AllowPaging="true">
                <GridPageSettings PageSize="10"></GridPageSettings>
                <GridColumns>
                    <GridColumn Field="@nameof(FlowDisplay.Name)" HeaderText="Name" Width="200"></GridColumn>
                    <GridColumn Field="@nameof(FlowDisplay.Description)" HeaderText="Description" Width="300"></GridColumn>
                    <GridColumn Field="@nameof(FlowDisplay.NodeCount)" HeaderText="Nodes" Width="80"></GridColumn>
                    <GridColumn HeaderText="Status" Width="100">
                        <Template>
                            @{
                                var item = (context as FlowDisplay);
                                <span class="status-indicator @(item?.Enabled == true ? "enabled" : "disabled")">
                                    <i class="fa-solid fa-circle"></i> @(item?.Enabled == true ? "Enabled" : "Disabled")
                                </span>
                            }
                        </Template>
                    </GridColumn>
                    <GridColumn HeaderText="Actions" Width="120">
                        <Template>
                            @{
                                var item = (context as FlowDisplay);
                                <div class="action-buttons">
                                    <SfButton CssClass="e-flat e-small" IconCss="fa-solid fa-pen" @onclick="() => EditFlow(item!.Id)"></SfButton>
                                    <SfButton CssClass="e-flat e-small e-danger" IconCss="fa-solid fa-trash" @onclick="() => ConfirmDeleteFlow(item!.Id)"></SfButton>
                                </div>
                            }
                        </Template>
                    </GridColumn>
                </GridColumns>
            </SfGrid>
        }
    }
    else
    {
        <!-- Flow Editor View -->
        <div class="flow-editor">
            <div class="editor-toolbar">
                <SfButton CssClass="e-flat" IconCss="fa-solid fa-arrow-left" @onclick="GoBack"></SfButton>
                <SfTextBox @bind-Value="CurrentFlow.Name" Placeholder="Flow Name" CssClass="flow-name-input"></SfTextBox>
                <div class="toolbar-spacer"></div>
                @if (!string.IsNullOrEmpty(_editingSubflowId))
                {
                    <span class="editing-subflow-badge"><i class="fa-solid fa-object-group"></i> Editing Subflow</span>
                    <SfButton CssClass="e-primary" IconCss="fa-solid fa-floppy-disk" @onclick="SaveSubflow">Save Subflow</SfButton>
                    <SfButton CssClass="e-flat" @onclick="CancelSubflowEdit">Cancel</SfButton>
                }
                else
                {
                    <SfButton CssClass="e-flat" IconCss="fa-solid fa-layer-group" Content="Templates" @onclick="ShowTemplates" title="Apply Template"></SfButton>
                    <SfButton CssClass="e-flat" IconCss="fa-solid fa-file-export" @onclick="SaveAsTemplate" title="Save as Template"></SfButton>
                    <SfButton CssClass="e-flat" IconCss="fa-solid fa-object-group" @onclick="CreateSubflowFromSelection" title="Create Subflow from Selection"></SfButton>
                    <span class="toolbar-separator"></span>
                    <SfButton CssClass="@(CurrentFlow.Enabled ? "e-warning" : "e-success")" 
                              IconCss="@(CurrentFlow.Enabled ? "fa-solid fa-pause" : "fa-solid fa-play")"
                              Content="@(CurrentFlow.Enabled ? "Disable" : "Enable")"
                              @onclick="ToggleEnabled"></SfButton>
                    <SfButton CssClass="e-primary" IconCss="fa-solid fa-floppy-disk" @onclick="SaveFlow">Save</SfButton>
                    <span class="toolbar-separator"></span>
                    <SfButton CssClass="e-info" IconCss="fa-solid fa-play-circle" Content="Test" @onclick="RunFlowSimulation"></SfButton>
                }
            </div>
            
            <div class="editor-content">
                <!-- Node Palette (Custom HTML5 - not hardcoded, from NodeRegistry) -->
                <div class="node-palette">
                    <div class="palette-header">NODE PALETTE</div>
                    @foreach (var category in NodeRegistry.Categories)
                    {
                        var plugins = NodeRegistry.GetByCategory(category);
                        if (!plugins.Any()) continue;
                        
                        <div class="palette-category">
                            <div class="category-header" @onclick="() => ToggleCategory(category)">
                                <span class="toggle-icon">@(ExpandedCategories.Contains(category) ? "▼" : "▶")</span>
                                @category.ToUpperInvariant()
                            </div>
                            @if (ExpandedCategories.Contains(category))
                            {
                                <div class="category-nodes">
                                    @foreach (var plugin in plugins)
                                    {
                                        <div class="palette-node" 
                                             draggable="true"
                                             style="border-left-color: @plugin.Color"
                                             @ondragstart="() => OnPaletteDragStart(plugin)"
                                             @onclick="() => AddNodeFromPalette(plugin)">
                                            <span class="node-icon"><i class="@plugin.Icon" style="color: @plugin.Color"></i></span>
                                            <span class="node-label">@plugin.ShortLabel</span>
                                            @if (category == "Subflows")
                                            {
                                                <span class="subflow-actions" @onclick:stopPropagation="true">
                                                    <button class="subflow-edit-btn" @onclick="() => EditSubflow(plugin.Id)" title="Edit Subflow">
                                                        <i class="fa-solid fa-pen-to-square"></i>
                                                    </button>
                                                </span>
                                            }
                                        </div>
                                    }
                                </div>
                            }
                        </div>
                    }
                </div>
                
                <!-- Diagram Canvas -->
                <div class="diagram-container" 
                     id="diagram-space"
                     @ondragover="OnDiagramDragOver"
                     @ondragover:preventDefault="true"
                     @ondrop="OnDiagramDrop"
                     @ondrop:preventDefault="true">
                    <SfDiagramComponent @ref="Diagram" 
                                        ID="diagram"
                                        Width="100%" 
                                        Height="100%"
                                        Nodes="@Nodes"
                                        Connectors="@Connectors"
                                        NodeCreating="@OnNodeCreating"
                                        ConnectorCreating="@OnConnectorCreating"
                                        SelectionChanged="@OnSelectionChanged"
                                        ConnectionChanged="@OnConnectionChanged">
                        <SnapSettings>
                            <HorizontalGridLines LineColor="#3a4049" LineDashArray="2,4"></HorizontalGridLines>
                            <VerticalGridLines LineColor="#3a4049" LineDashArray="2,4"></VerticalGridLines>
                        </SnapSettings>
                        <ScrollSettings ScrollLimit="ScrollLimitMode.Diagram"></ScrollSettings>
                    </SfDiagramComponent>
                </div>
                
                <!-- Properties Panel -->
                <div class="properties-panel">
                    <h3>Properties</h3>
                    @if (SelectedNode != null)
                    {
                        var plugin = NodeRegistry.Get(GetNodeBaseType(SelectedNode));
                        <div class="property-header">
                            <span class="node-type-badge" style="border-color: @(plugin?.Color ?? "#9ca3af")">
                                <i class="@(plugin?.Icon ?? "fa-solid fa-question")" style="color: @(plugin?.Color ?? "#9ca3af")"></i>
                                @(plugin?.Name ?? GetNodeType(SelectedNode))
                            </span>
                        </div>
                        
                        @if (plugin != null)
                        {
                            <p class="plugin-description">@plugin.Description</p>
                        }
                        
                        <div class="property-group">
                            <label>Label</label>
                            <SfTextBox Value="@SelectedNodeLabel" ValueChanged="@OnLabelChanged"></SfTextBox>
                        </div>
                        
                        @if (plugin != null)
                        {
                            @foreach (var prop in plugin.Properties.Where(p => !p.Advanced))
                            {
                                <div class="property-group">
                                    <label>@prop.Label @(prop.Required ? "*" : "")</label>
                                    @RenderPropertyInput(prop)
                                    @if (!string.IsNullOrEmpty(prop.HelpText))
                                    {
                                        <span class="property-hint">@prop.HelpText</span>
                                    }
                                </div>
                            }
                        }
                        
                        <div class="property-actions">
                            <SfButton CssClass="e-danger e-small" IconCss="fa-solid fa-trash" @onclick="DeleteSelectedNode">Delete Node</SfButton>
                        </div>
                    }
                    else
                    {
                        <p class="no-selection">Select a node to view properties</p>
                    }
                    
                    <div class="flow-settings">
                        <h4>Flow Settings</h4>
                        <div class="property-group">
                            <label>Description</label>
                            <SfTextBox @bind-Value="CurrentFlow.Description" Multiline="true"></SfTextBox>
                        </div>
                        <div class="property-group">
                            <label>Scan Rate (ms)</label>
                            <SfNumericTextBox TValue="int" @bind-Value="CurrentFlow.ScanRateMs" Min="10" Max="60000"></SfNumericTextBox>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Collapsible Output Console -->
            <div class="output-console @(ConsoleExpanded ? "expanded" : "collapsed")">
                <div class="console-header" @onclick="ToggleConsole">
                    <span class="console-toggle"><i class="fa-solid @(ConsoleExpanded ? "fa-chevron-down" : "fa-chevron-up")"></i></span>
                    <span class="console-title"><i class="fa-solid fa-terminal"></i> Output Console</span>
                    <span class="console-badge">@ConsoleMessages.Count</span>
                    <div class="console-actions" @onclick:stopPropagation="true">
                        <SfButton CssClass="e-flat e-small" IconCss="fa-solid fa-trash" OnClick="@ClearConsole" title="Clear Console"></SfButton>
                        <SfButton CssClass="e-flat e-small e-success" IconCss="fa-solid fa-play" OnClick="@RunFlowSimulation" title="Test Run"></SfButton>
                    </div>
                </div>
                @if (ConsoleExpanded)
                {
                    <div class="console-body" @ref="ConsoleBody">
                        @if (!ConsoleMessages.Any())
                        {
                            <div class="console-empty">No output yet. Click <i class="fa-solid fa-play"></i> to test the flow.</div>
                        }
                        else
                        {
                            @foreach (var msg in ConsoleMessages)
                            {
                                <div class="console-line @msg.Level.ToLower()">
                                    <span class="console-time">@msg.Timestamp.ToString("HH:mm:ss.fff")</span>
                                    <span class="console-level">[@msg.Level]</span>
                                    <span class="console-node">@msg.NodeLabel</span>
                                    <span class="console-text">@msg.Message</span>
                                </div>
                            }
                        }
                    </div>
                }
            </div>
        </div>
    }
</div>

<!-- Delete Confirmation Dialog -->
@if (ShowDeleteDialog)
{
    <SfDialog @bind-Visible="ShowDeleteDialog" Width="350px" IsModal="true" ShowCloseIcon="true">
        <DialogTemplates>
            <Header>Confirm Delete</Header>
            <Content>
                <p>Delete this flow?</p>
                <p class="text-muted">This action cannot be undone.</p>
            </Content>
            <FooterTemplate>
                <SfButton @onclick="() => ShowDeleteDialog = false">Cancel</SfButton>
                <SfButton CssClass="e-danger" @onclick="ExecuteDeleteFlow">Delete</SfButton>
            </FooterTemplate>
        </DialogTemplates>
    </SfDialog>
}

<!-- Template Selection Dialog -->
@if (ShowTemplateDialog)
{
    <SfDialog @bind-Visible="ShowTemplateDialog" Width="500px" IsModal="true" ShowCloseIcon="true">
        <DialogTemplates>
            <Header><i class="fa-solid fa-layer-group"></i> Flow Templates</Header>
            <Content>
                @if (!AvailableTemplates.Any())
                {
                    <p class="text-muted">No templates available. Save a flow as template first.</p>
                }
                else
                {
                    <div class="template-list">
                        @foreach (var template in AvailableTemplates)
                        {
                            <div class="template-card" @onclick="() => ApplyTemplate(template)">
                                <div class="template-name"><i class="fa-solid fa-file-code"></i> @template.Name</div>
                                <div class="template-description">@template.Description</div>
                                <div class="template-meta">
                                    <span class="template-category">@template.Category</span>
                                    <span class="template-nodes">@template.Nodes.Count nodes</span>
                                </div>
                            </div>
                        }
                    </div>
                }
            </Content>
            <FooterTemplate>
                <SfButton @onclick="() => ShowTemplateDialog = false">Close</SfButton>
            </FooterTemplate>
        </DialogTemplates>
    </SfDialog>
}

<!-- Replace with Subflow Dialog -->
@if (ShowReplaceWithSubflowDialog)
{
    <SfDialog @bind-Visible="ShowReplaceWithSubflowDialog" Width="400px" IsModal="true" ShowCloseIcon="true">
        <DialogTemplates>
            <Header><i class="fa-solid fa-object-group"></i> Subflow Created</Header>
            <Content>
                <p>Subflow has been created and added to the palette.</p>
                <p>Would you like to replace the selected nodes with the new subflow node?</p>
            </Content>
            <FooterTemplate>
                <SfButton @onclick="() => { ShowReplaceWithSubflowDialog = false; PendingSubflowId = string.Empty; }">Keep Nodes</SfButton>
                <SfButton CssClass="e-primary" @onclick="ReplaceSelectionWithSubflow">Replace with Subflow</SfButton>
            </FooterTemplate>
        </DialogTemplates>
    </SfDialog>
}

@code {
    [Parameter] public string? FlowId { get; set; }
    
    private SfDiagramComponent? Diagram;
    private DiagramObjectCollection<Node> Nodes = new();
    private DiagramObjectCollection<Connector> Connectors = new();
    private Node? SelectedNode;
    private string SelectedNodeLabel = "";
    
    // Palette state
    private HashSet<string> ExpandedCategories = new() { "Triggers", "Tags" };
    private NodePluginDefinition? _draggingPlugin;
    
    private FlowConfig CurrentFlow = new();
    private bool ShowDeleteDialog;
    private string DeleteFlowId = "";
    private string? _lastLoadedFlowId; // Track to detect navigation changes
    
    // Node property values storage
    private Dictionary<string, Dictionary<string, object>> NodeProperties = new();
    
    // Node type mapping (for looking up plugin info)
    private Dictionary<string, string> _nodeTypes = new();
    
    // Pending connectors (added after diagram is rendered)
    private DiagramObjectCollection<Connector> _pendingConnectors = new();
    private bool _connectorsAdded = false;
    
    // Output Console
    private bool ConsoleExpanded = true;
    private List<ConsoleLogMessage> ConsoleMessages = new();
    private ElementReference ConsoleBody;
    private System.Timers.Timer? _simulationTimer;

    private List<FlowDisplay> FlowsList => ConfigService.Flows.Select(f => new FlowDisplay
    {
        Id = f.Id,
        Name = f.Name,
        Description = f.Description ?? "",
        NodeCount = f.Nodes.Count,
        Enabled = f.Enabled
    }).ToList();

    protected override async Task OnInitializedAsync()
    {
        await ConfigService.LoadAllAsync();
        
        // Subscribe to real-time data events
        RealtimeData.OnTagValueChanged += HandleTagValueChanged;
        
        // Load flow definition if FlowId is set
        if (!string.IsNullOrEmpty(FlowId) && FlowId != "new")
        {
            _lastLoadedFlowId = FlowId;
            var flow = ConfigService.Flows.FirstOrDefault(f => f.Id == FlowId);
            if (flow != null)
            {
                CurrentFlow = flow;
                LoadFlowDefinition(flow);
                Console.WriteLine($"Loaded flow {flow.Name} with {Nodes.Count} nodes and {_pendingConnectors.Count} pending connectors");
            }
        }
        else if (FlowId == "new")
        {
            CurrentFlow = new FlowConfig { Name = "New Flow" };
            _lastLoadedFlowId = "new";
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        // Handle parameter changes (navigating between flows)
        if (FlowId != _lastLoadedFlowId)
        {
            _lastLoadedFlowId = FlowId;
            
            if (!string.IsNullOrEmpty(FlowId) && FlowId != "new")
            {
                var flow = ConfigService.Flows.FirstOrDefault(f => f.Id == FlowId);
                if (flow != null)
                {
                    CurrentFlow = flow;
                    
                    // Clear existing collections before loading new flow
                    Nodes.Clear();
                    Connectors.Clear();
                    _pendingConnectors.Clear();
                    
                    LoadFlowDefinition(flow);
                    _connectorsAdded = false;
                    ConsoleMessages.Clear();
                    AddConsoleMessage("INFO", "System", $"Loaded flow: {flow.Name}");
                    StateHasChanged();
                }
            }
            else if (FlowId == "new")
            {
                CurrentFlow = new FlowConfig { Name = "New Flow" };
                Nodes.Clear();
                Connectors.Clear();
                _pendingConnectors.Clear();
                NodeProperties.Clear();
                _nodeTypes.Clear();
                ConsoleMessages.Clear();
                StateHasChanged();
            }
            else
            {
                // Returning to flow list - clear state
                Nodes.Clear();
                Connectors.Clear();
                _pendingConnectors.Clear();
            }
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        Console.WriteLine($"OnAfterRenderAsync: firstRender={firstRender}, Nodes.Count={Nodes.Count}, _pendingConnectors.Count={_pendingConnectors.Count}, Diagram null={Diagram == null}");
        
        // Add connectors after nodes are fully rendered
        if (!_connectorsAdded && Diagram != null && _pendingConnectors.Count > 0)
        {
            _connectorsAdded = true;
            Console.WriteLine($"Adding {_pendingConnectors.Count} connectors to diagram...");
            
            // Wait for nodes to be fully rendered
            await Task.Delay(500);
            
            try
            {
                // Add connectors using Diagram API
                var connectorsToAdd = _pendingConnectors.ToList();
                await Diagram.AddDiagramElementsAsync(new DiagramObjectCollection<NodeBase>(connectorsToAdd.Cast<NodeBase>()));
                _pendingConnectors.Clear();
                Console.WriteLine($"Successfully added {connectorsToAdd.Count} connectors");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to add connectors: {ex.Message}");
            }
        }
    }
    
    private void HandleTagValueChanged(string tagId)
    {
        // Check if any node in the current flow uses this tag
        foreach (var nodeEntry in NodeProperties)
        {
            if (nodeEntry.Value.TryGetValue("tagPath", out var tagPath) && 
                tagPath?.ToString() == tagId)
            {
                var tagValue = RealtimeData.GetTagValue(tagId);
                if (tagValue != null)
                {
                    var nodeLabel = Nodes.FirstOrDefault(n => n.ID == nodeEntry.Key)?.Annotations?.FirstOrDefault()?.Content ?? nodeEntry.Key;
                    AddConsoleMessage("DATA", nodeLabel?.ToString() ?? "Unknown", $"Tag value: {tagValue.FormattedValue} (Quality: {tagValue.QualityText})");
                    InvokeAsync(StateHasChanged);
                }
            }
        }
    }

    private void LoadFlowDefinition(FlowConfig flow)
    {
        // Clear existing collections (instead of creating new ones to maintain binding)
        Nodes.Clear();
        Connectors.Clear();
        _pendingConnectors.Clear();
        NodeProperties.Clear();
        _nodeTypes.Clear();
        
        foreach (var node in flow.Nodes)
        {
            // Map legacy type names to plugin IDs
            var mappedType = MapNodeType(node.Type);
            var plugin = NodeRegistry.Get(mappedType);
            var diagramNode = CreateFlowNode(
                node.Id,
                node.Label ?? plugin?.Name ?? node.Type,
                plugin?.Color ?? "#9ca3af",
                node.X,
                node.Y,
                plugin?.InputCount ?? 1,
                plugin?.OutputCount ?? 1
            );
            // Add directly to Nodes collection so it's available when diagram renders
            Nodes.Add(diagramNode);
            
            // Store node type mapping (store the mapped type for proper plugin lookup)
            _nodeTypes[node.Id] = mappedType;
            
            // Store node properties
            if (node.Properties != null)
            {
                NodeProperties[node.Id] = new Dictionary<string, object>(node.Properties);
            }
        }
        
        // Add connectors to pending list - they'll be added after nodes render
        foreach (var edge in flow.Edges)
        {
            // Map semantic port names to indexed port IDs
            var mappedSourcePort = MapPortName(edge.SourcePortId, "output");
            var mappedTargetPort = MapPortName(edge.TargetPortId, "input");
            
            _pendingConnectors.Add(CreateFlowConnector(
                edge.Id,
                edge.SourceNodeId,
                mappedSourcePort,
                edge.TargetNodeId,
                mappedTargetPort
            ));
        }
        
        _connectorsAdded = false;
    }

    /// <summary>
    /// Maps legacy node type names to plugin registry IDs
    /// Config files may use names like "TagInput", "Compare" but registry uses "tag-input", "logic-compare"
    /// </summary>
    private string MapNodeType(string? nodeType)
    {
        if (string.IsNullOrEmpty(nodeType))
            return "unknown";
            
        // If it already matches a plugin ID, return as-is
        if (NodeRegistry.Get(nodeType) != null)
            return nodeType;
        
        // Map legacy names to plugin IDs
        return nodeType.ToLower() switch
        {
            "taginput" => "tag-input",
            "tagoutput" => "tag-output",
            "compare" => "logic-compare",
            "debug" => "output-log",
            "notification" => "output-notification",
            "timer" => "trigger-schedule",
            "inject" => "trigger-manual",
            "multiply" => "math-multiply",
            "divide" => "math-divide",
            "add" => "math-add",
            "subtract" => "math-subtract",
            "scale" => "math-scale",
            "smooth" => "data-smooth",
            "mqttin" => "mqtt-in",
            "mqttout" => "mqtt-out",
            "template" => "func-template",
            "switch" => "func-switch",
            "branch" => "logic-branch",
            "and" => "logic-and",
            "or" => "logic-or",
            "delay" => "util-delay",
            "filter" => "util-filter",
            "constant" => "util-constant",
            "aggregate" => "data-aggregate",
            "deadband" => "data-deadband",
            "rateofchange" => "data-rateofchange",
            "httprequest" => "http-request",
            "javascript" => "func-javascript",
            _ => nodeType.ToLower() // Try lowercase as fallback
        };
    }

    /// <summary>
    /// Maps semantic port names from flow definitions to actual port IDs
    /// Config uses names like "input", "output", "true", "input1" but diagram uses "input-0", "output-0"
    /// </summary>
    private string MapPortName(string? portName, string portType)
    {
        if (string.IsNullOrEmpty(portName))
            return $"{portType}-0";
        
        // If already in correct format, return as-is
        if (portName.StartsWith("input-") || portName.StartsWith("output-"))
            return portName;
        
        // Handle simple "input" or "output" -> first port
        if (portName.Equals("input", StringComparison.OrdinalIgnoreCase) ||
            portName.Equals("output", StringComparison.OrdinalIgnoreCase))
            return $"{portType}-0";
        
        // Handle boolean outputs like "true", "false"
        if (portName.Equals("true", StringComparison.OrdinalIgnoreCase))
            return "output-0";
        if (portName.Equals("false", StringComparison.OrdinalIgnoreCase))
            return "output-1";
        
        // Handle numbered ports: "input1" -> "input-0", "input2" -> "input-1"
        if (portName.StartsWith("input", StringComparison.OrdinalIgnoreCase) && 
            portName.Length > 5 && int.TryParse(portName[5..], out var inputNum))
            return $"input-{inputNum - 1}";
        
        if (portName.StartsWith("output", StringComparison.OrdinalIgnoreCase) && 
            portName.Length > 6 && int.TryParse(portName[6..], out var outputNum))
            return $"output-{outputNum - 1}";
        
        // Handle semantic names (map to appropriate type's first port)
        // This handles names like "value", "trigger", "temp", "pressure", etc.
        return $"{portType}-0";
    }

    private void CreateNewFlow() => Navigation.NavigateTo("/flows/new");
    private void EditFlow(string id) => Navigation.NavigateTo($"/flows/{id}");
    private void GoBack() => Navigation.NavigateTo("/flows");
    
    private void ToggleEnabled() => CurrentFlow.Enabled = !CurrentFlow.Enabled;

    private async Task SaveFlow()
    {
        // Convert diagram nodes to flow nodes
        CurrentFlow.Nodes = Nodes.Select(n => new FlowNode
        {
            Id = n.ID,
            Type = GetNodeBaseType(n),
            Label = GetNodeLabel(n),
            X = n.OffsetX,
            Y = n.OffsetY,
            Properties = NodeProperties.TryGetValue(n.ID, out var props) ? props : new()
        }).ToList();
        
        // Convert connectors to edges
        CurrentFlow.Edges = Connectors.Select(c => new FlowEdge
        {
            Id = c.ID,
            SourceNodeId = c.SourceID,
            SourcePortId = c.SourcePortID,
            TargetNodeId = c.TargetID,
            TargetPortId = c.TargetPortID
        }).ToList();
        
        CurrentFlow.UpdatedAt = DateTime.UtcNow;
        
        if (FlowId == "new")
        {
            await ConfigService.AddFlowAsync(CurrentFlow);
        }
        else
        {
            await ConfigService.UpdateFlowAsync(CurrentFlow);
        }
        
        Navigation.NavigateTo("/flows");
    }

    private void ConfirmDeleteFlow(string id)
    {
        DeleteFlowId = id;
        ShowDeleteDialog = true;
    }

    private async Task ExecuteDeleteFlow()
    {
        await ConfigService.DeleteFlowAsync(DeleteFlowId);
        ShowDeleteDialog = false;
    }

    // Palette interactions
    private void ToggleCategory(string category)
    {
        if (ExpandedCategories.Contains(category))
            ExpandedCategories.Remove(category);
        else
            ExpandedCategories.Add(category);
    }

    private void OnPaletteDragStart(NodePluginDefinition plugin)
    {
        _draggingPlugin = plugin;
    }

    private void OnDiagramDragOver(Microsoft.AspNetCore.Components.Web.DragEventArgs e)
    {
        e.DataTransfer.DropEffect = "copy";
    }

    private async Task OnDiagramDrop(Microsoft.AspNetCore.Components.Web.DragEventArgs e)
    {
        if (_draggingPlugin == null || Diagram == null) return;
        
        try
        {
            var diagramRect = await JSRuntime.InvokeAsync<Dictionary<string, double>>(
                "eval", 
                "(() => { const rect = document.getElementById('diagram-space').getBoundingClientRect(); return { left: rect.left, top: rect.top }; })()");
            
            double diagramX = e.ClientX - diagramRect["left"];
            double diagramY = e.ClientY - diagramRect["top"];
            
            await AddNodeFromPalette(_draggingPlugin, diagramX, diagramY);
        }
        finally
        {
            _draggingPlugin = null;
        }
    }

    private async Task AddNodeFromPalette(NodePluginDefinition plugin, double? x = null, double? y = null)
    {
        if (Diagram == null) return;
        
        double offsetX = x ?? (400 + (Nodes.Count % 4) * 220);
        double offsetY = y ?? (150 + (Nodes.Count / 4) * 120);
        
        var nodeId = $"{plugin.Id}-{Guid.NewGuid():N}";
        var node = CreateFlowNode(
            nodeId,
            plugin.Name,
            plugin.Color,
            offsetX, offsetY,
            plugin.InputCount, plugin.OutputCount
        );
        
        // Initialize default properties (cast to object)
        NodeProperties[nodeId] = plugin.Properties
            .Where(p => !string.IsNullOrEmpty(p.DefaultValue))
            .ToDictionary(p => p.Key, p => (object)p.DefaultValue);
        
        Nodes.Add(node);
        StateHasChanged();
    }

    private Node CreateFlowNode(string id, string label, string color, double x, double y, int inputCount, int outputCount)
    {
        var baseType = GetBaseTypeFromId(id);
        var plugin = NodeRegistry.Get(baseType);
        
        var node = new Node
        {
            ID = id,
            OffsetX = x,
            OffsetY = y,
            Width = 180,
            Height = 70,
            Shape = new BasicShape { Type = NodeShapes.Basic, Shape = NodeBasicShapes.Rectangle, CornerRadius = 8 },
            Style = new ShapeStyle { Fill = "#2a2a2a", StrokeColor = color, StrokeWidth = 2 },
            Annotations = new DiagramObjectCollection<ShapeAnnotation>(),
            Ports = new DiagramObjectCollection<PointPort>(),
            Constraints = NodeConstraints.Default | NodeConstraints.AllowDrop
        };
        
        // Main label
        node.Annotations.Add(new ShapeAnnotation
        {
            Content = label,
            Style = new TextStyle { Color = "#ffffff", FontSize = 13, Bold = true },
            Offset = new DiagramPoint { X = 0.5, Y = 0.35 },
            HorizontalAlignment = HorizontalAlignment.Center
        });
        
        // Category subtitle
        var category = plugin?.Category ?? "Node";
        node.Annotations.Add(new ShapeAnnotation
        {
            Content = category,
            Style = new TextStyle { Color = "#9d9d9d", FontSize = 10, Italic = true },
            Offset = new DiagramPoint { X = 0.5, Y = 0.7 },
            HorizontalAlignment = HorizontalAlignment.Center
        });
        
        // Input ports
        for (int i = 0; i < inputCount; i++)
        {
            var yOffset = inputCount == 1 ? 0.5 : (i + 1.0) / (inputCount + 1);
            node.Ports.Add(new PointPort
            {
                ID = $"input-{i}",
                Offset = new DiagramPoint { X = 0, Y = yOffset },
                Visibility = PortVisibility.Visible,
                Shape = PortShapes.Circle,
                Width = 12, Height = 12,
                Style = new ShapeStyle { Fill = "#3b82f6", StrokeColor = "#ffffff", StrokeWidth = 2 },
                Constraints = PortConstraints.Default | PortConstraints.Draw
            });
        }
        
        // Output ports
        for (int i = 0; i < outputCount; i++)
        {
            var yOffset = outputCount == 1 ? 0.5 : (i + 1.0) / (outputCount + 1);
            node.Ports.Add(new PointPort
            {
                ID = $"output-{i}",
                Offset = new DiagramPoint { X = 1, Y = yOffset },
                Visibility = PortVisibility.Visible,
                Shape = PortShapes.Circle,
                Width = 12, Height = 12,
                Style = new ShapeStyle { Fill = "#f59e0b", StrokeColor = "#ffffff", StrokeWidth = 2 },
                Constraints = PortConstraints.Default | PortConstraints.Draw
            });
        }
        
        return node;
    }

    private Connector CreateFlowConnector(string id, string sourceId, string? sourcePort, string targetId, string? targetPort)
    {
        return new Connector
        {
            ID = id,
            SourceID = sourceId,
            SourcePortID = sourcePort ?? "output-0",
            TargetID = targetId,
            TargetPortID = targetPort ?? "input-0",
            Type = ConnectorSegmentType.Orthogonal,
            Style = new ShapeStyle { StrokeColor = "#4caf50", StrokeWidth = 2 },
            CornerRadius = 5,
            TargetDecorator = new DecoratorSettings
            {
                Shape = DecoratorShape.Arrow,
                Width = 10,
                Height = 10,
                Style = new ShapeStyle { Fill = "#4caf50", StrokeColor = "#4caf50" }
            }
        };
    }

    private void OnNodeCreating(IDiagramObject obj)
    {
        if (obj is Node node)
        {
            node.Style.Fill = "#2a2a2a";
            
            // Ensure ports are visible and properly configured for port-to-port connections
            if (node.Ports != null)
            {
                foreach (var port in node.Ports)
                {
                    port.Visibility = PortVisibility.Visible;
                    port.Width = 12;
                    port.Height = 12;
                    port.Constraints = PortConstraints.Default | PortConstraints.Draw;
                }
            }
        }
    }

    private void OnConnectorCreating(IDiagramObject obj)
    {
        if (obj is Connector connector)
        {
            connector.Type = ConnectorSegmentType.Orthogonal;
            connector.Style = new ShapeStyle { StrokeColor = "#4caf50", StrokeWidth = 2 };
            connector.CornerRadius = 5;
            
            // Set arrow decorator
            connector.TargetDecorator = new DecoratorSettings
            {
                Shape = DecoratorShape.Arrow,
                Width = 10,
                Height = 10,
                Style = new ShapeStyle { Fill = "#4caf50", StrokeColor = "#4caf50" }
            };
        }
    }

    private void OnConnectionChanged(Syncfusion.Blazor.Diagram.ConnectionChangedEventArgs args)
    {
        // Log connection changes to console
        if (args.Connector != null && !string.IsNullOrEmpty(args.Connector.SourceID) && !string.IsNullOrEmpty(args.Connector.TargetID))
        {
            var sourceNode = Nodes.FirstOrDefault(n => n.ID == args.Connector.SourceID);
            var targetNode = Nodes.FirstOrDefault(n => n.ID == args.Connector.TargetID);
            
            var sourceLabel = sourceNode != null ? GetNodeLabel(sourceNode) : args.Connector.SourceID;
            var targetLabel = targetNode != null ? GetNodeLabel(targetNode) : args.Connector.TargetID;
            var sourcePort = args.Connector.SourcePortID ?? "output-0";
            var targetPort = args.Connector.TargetPortID ?? "input-0";
            
            AddConsoleMessage("INFO", "System", $"Connected: {sourceLabel}[{sourcePort}] → {targetLabel}[{targetPort}]");
        }
    }

    private void OnSelectionChanged(Syncfusion.Blazor.Diagram.SelectionChangedEventArgs args)
    {
        if (args.NewValue?.Count > 0 && args.NewValue[0] is Node node)
        {
            SelectedNode = node;
            SelectedNodeLabel = GetNodeLabel(node);
        }
        else
        {
            SelectedNode = null;
            SelectedNodeLabel = "";
        }
    }

    private async Task OnLabelChanged(string newLabel)
    {
        if (SelectedNode == null || Diagram == null) return;
        
        SelectedNodeLabel = newLabel;
        if (SelectedNode.Annotations.Count > 0)
        {
            SelectedNode.Annotations[0].Content = newLabel;
            StateHasChanged();
        }
    }

    private async Task DeleteSelectedNode()
    {
        if (SelectedNode == null || Diagram == null) return;
        
        var nodeId = SelectedNode.ID;
        Nodes.Remove(SelectedNode);
        NodeProperties.Remove(nodeId);
        
        // Remove connected connectors
        var connectedConnectors = Connectors.Where(c => c.SourceID == nodeId || c.TargetID == nodeId).ToList();
        foreach (var conn in connectedConnectors)
        {
            Connectors.Remove(conn);
        }
        
        SelectedNode = null;
        StateHasChanged();
    }

    private string GetNodeLabel(Node node) => node.Annotations?.FirstOrDefault()?.Content ?? node.ID;
    private string GetNodeType(Node node) => GetBaseTypeFromId(node.ID);
    private string GetNodeBaseType(Node node) => GetBaseTypeFromId(node.ID);
    
    private string GetBaseTypeFromId(string id)
    {
        // Handle IDs like "trigger-manual-abc123" or "math-add-instance-xyz"
        if (id.Contains("-instance-"))
            return id.Split("-instance-")[0];
        
        // Try to match against known plugin IDs
        var parts = id.Split('-');
        for (int i = parts.Length; i > 0; i--)
        {
            var candidate = string.Join("-", parts.Take(i));
            if (NodeRegistry.Get(candidate) != null)
                return candidate;
        }
        
        // Fallback: remove last segment if it looks like a GUID
        if (parts.Length > 1 && parts[^1].Length >= 8)
            return string.Join("-", parts.Take(parts.Length - 1));
        
        return id;
    }

    private RenderFragment RenderPropertyInput(NodePropertyDefinition prop) => builder =>
    {
        var nodeId = SelectedNode?.ID;
        if (nodeId == null) return;
        
        if (!NodeProperties.ContainsKey(nodeId))
            NodeProperties[nodeId] = new();
        
        var currentValue = NodeProperties[nodeId].TryGetValue(prop.Key, out var v) ? v?.ToString() : prop.DefaultValue;
        
        switch (prop.Type)
        {
            case PropertyType.Text:
                builder.OpenComponent<SfTextBox>(0);
                builder.AddAttribute(1, "Value", currentValue ?? "");
                builder.AddAttribute(2, "ValueChanged", EventCallback.Factory.Create<string>(this, val => SetPropertyValue(nodeId, prop.Key, val)));
                builder.AddAttribute(3, "Placeholder", prop.Placeholder);
                builder.CloseComponent();
                break;
                
            case PropertyType.Integer:
                builder.OpenComponent<SfNumericTextBox<int>>(0);
                builder.AddAttribute(1, "Value", int.TryParse(currentValue, out var intVal) ? intVal : 0);
                builder.AddAttribute(2, "ValueChanged", EventCallback.Factory.Create<int>(this, val => SetPropertyValue(nodeId, prop.Key, val.ToString())));
                builder.AddAttribute(3, "Min", (int)(prop.Min ?? int.MinValue));
                builder.AddAttribute(4, "Max", (int)(prop.Max ?? int.MaxValue));
                builder.CloseComponent();
                break;
                
            case PropertyType.Decimal:
                builder.OpenComponent<SfNumericTextBox<double>>(0);
                builder.AddAttribute(1, "Value", double.TryParse(currentValue, out var dblVal) ? dblVal : 0);
                builder.AddAttribute(2, "ValueChanged", EventCallback.Factory.Create<double>(this, val => SetPropertyValue(nodeId, prop.Key, val.ToString())));
                builder.CloseComponent();
                break;
                
            case PropertyType.Boolean:
                builder.OpenComponent<SfCheckBox<bool>>(0);
                builder.AddAttribute(1, "Checked", currentValue?.ToLower() == "true");
                builder.AddAttribute(2, "CheckedChanged", EventCallback.Factory.Create<bool>(this, val => SetPropertyValue(nodeId, prop.Key, val.ToString().ToLower())));
                builder.CloseComponent();
                break;
                
            case PropertyType.Select:
                // For select, just render a simple text input for now (complex dropdowns need different handling)
                builder.OpenComponent<SfTextBox>(0);
                builder.AddAttribute(1, "Value", currentValue?.ToString() ?? "");
                builder.AddAttribute(2, "ValueChanged", EventCallback.Factory.Create<string>(this, val => SetPropertyValue(nodeId, prop.Key, val)));
                builder.AddAttribute(3, "Placeholder", string.Join(", ", prop.Options.Select(o => o.Label)));
                builder.CloseComponent();
                break;
                
            case PropertyType.TextArea:
                builder.OpenComponent<SfTextBox>(0);
                builder.AddAttribute(1, "Value", currentValue?.ToString() ?? "");
                builder.AddAttribute(2, "ValueChanged", EventCallback.Factory.Create<string>(this, val => SetPropertyValue(nodeId, prop.Key, val)));
                builder.AddAttribute(3, "Multiline", true);
                builder.CloseComponent();
                break;
                
            default:
                builder.OpenComponent<SfTextBox>(0);
                builder.AddAttribute(1, "Value", currentValue?.ToString() ?? "");
                builder.AddAttribute(2, "ValueChanged", EventCallback.Factory.Create<string>(this, val => SetPropertyValue(nodeId, prop.Key, val)));
                builder.CloseComponent();
                break;
        }
    };

    private void SetPropertyValue(string nodeId, string key, object value)
    {
        if (!NodeProperties.ContainsKey(nodeId))
            NodeProperties[nodeId] = new();
        NodeProperties[nodeId][key] = value;
    }

    // Console methods
    private void ToggleConsole() => ConsoleExpanded = !ConsoleExpanded;
    
    private void ClearConsole()
    {
        ConsoleMessages.Clear();
        StateHasChanged();
    }
    
    private void AddConsoleMessage(string level, string nodeLabel, string message)
    {
        ConsoleMessages.Add(new ConsoleLogMessage
        {
            Timestamp = DateTime.Now,
            Level = level,
            NodeLabel = nodeLabel,
            Message = message
        });
        
        // Keep only last 500 messages
        if (ConsoleMessages.Count > 500)
            ConsoleMessages.RemoveAt(0);
            
        InvokeAsync(StateHasChanged);
    }
    
    private void RunFlowSimulation()
    {
        Console.WriteLine($"RunFlowSimulation called. Nodes.Count={Nodes.Count}, _nodeTypes.Count={_nodeTypes.Count}");
        _ = SimulateExecution();
    }
    
    private async Task SimulateExecution()
    {
        Console.WriteLine($"SimulateExecution called. Nodes.Count={Nodes.Count}");
        
        // If Nodes collection is empty but we have loaded node types, use the config directly
        if (!Nodes.Any() && _nodeTypes.Any())
        {
            AddConsoleMessage("INFO", "System", $"Executing flow from config: {CurrentFlow.Name}");
            await ExecuteFlowFromConfig();
            return;
        }
        
        if (!Nodes.Any())
        {
            AddConsoleMessage("WARN", "System", "No nodes to execute");
            return;
        }
        
        AddConsoleMessage("INFO", "System", $"Starting flow execution: {CurrentFlow.Name}");
        
        // Find trigger nodes (nodes with no inputs connected)
        var triggerNodes = Nodes.Where(n => 
        {
            var plugin = NodeRegistry.Get(GetNodeBaseType(n));
            return plugin?.Category == "Triggers";
        }).ToList();
        
        if (!triggerNodes.Any())
        {
            // If no trigger nodes, start from nodes with no incoming connections
            var nodesWithIncoming = Connectors.Select(c => c.TargetID).ToHashSet();
            triggerNodes = Nodes.Where(n => !nodesWithIncoming.Contains(n.ID)).ToList();
        }
        
        foreach (var triggerNode in triggerNodes)
        {
            await SimulateNodeExecution(triggerNode, new Dictionary<string, object> { ["value"] = GenerateSimulatedValue(triggerNode) });
        }
        
        AddConsoleMessage("INFO", "System", "Flow execution completed");
    }
    
    private async Task ExecuteFlowFromConfig()
    {
        AddConsoleMessage("INFO", "System", $"Starting flow execution: {CurrentFlow.Name}");
        
        // Find trigger nodes from config
        var triggerNodes = CurrentFlow.Nodes.Where(n =>
        {
            var mappedType = MapNodeType(n.Type);
            var plugin = NodeRegistry.Get(mappedType);
            return plugin?.Category == "Triggers";
        }).ToList();
        
        if (!triggerNodes.Any())
        {
            // If no triggers, start from nodes with no incoming connections
            var nodesWithIncoming = CurrentFlow.Edges.Select(e => e.TargetNodeId).ToHashSet();
            triggerNodes = CurrentFlow.Nodes.Where(n => !nodesWithIncoming.Contains(n.Id)).ToList();
        }
        
        foreach (var triggerNode in triggerNodes)
        {
            await ExecuteNodeFromConfig(triggerNode, new Dictionary<string, object> { ["value"] = GenerateSimulatedValueFromConfig(triggerNode) });
        }
        
        AddConsoleMessage("INFO", "System", "Flow execution completed");
    }
    
    private async Task ExecuteNodeFromConfig(FlowNode node, Dictionary<string, object> inputData)
    {
        var mappedType = MapNodeType(node.Type);
        var plugin = NodeRegistry.Get(mappedType);
        var label = node.Label ?? plugin?.Name ?? node.Type;
        
        // Simulate processing delay
        await Task.Delay(50);
        
        object outputValue = inputData.TryGetValue("value", out var val) ? val : 0.0;
        
        switch (plugin?.Category)
        {
            case "Triggers":
                outputValue = GenerateSimulatedValueFromConfig(node);
                AddConsoleMessage("INFO", label, $"Triggered with value: {outputValue}");
                break;
                
            case "Tags":
                if (mappedType.Contains("input"))
                {
                    // Get real value from RealtimeDataService if available
                    if (node.Properties?.TryGetValue("tagPath", out var tagPath) == true)
                    {
                        var tagValue = RealtimeData.GetTagValue(tagPath?.ToString() ?? "");
                        if (tagValue?.NumericValue != null)
                        {
                            outputValue = Math.Round(tagValue.NumericValue.Value, 2);
                            AddConsoleMessage("INFO", label, $"Read tag '{tagPath}': {outputValue} (Quality: {tagValue.QualityText})");
                        }
                        else
                        {
                            outputValue = Math.Round(new Random().NextDouble() * 100, 2);
                            AddConsoleMessage("WARN", label, $"No real data for tag '{tagPath}', using simulated: {outputValue}");
                        }
                    }
                    else
                    {
                        outputValue = Math.Round(new Random().NextDouble() * 100, 2);
                        AddConsoleMessage("INFO", label, $"Read tag value (simulated): {outputValue}");
                    }
                }
                else
                {
                    AddConsoleMessage("INFO", label, $"Writing value: {outputValue}");
                }
                break;
                
            case "Math":
                var factor = node.Properties?.TryGetValue("factor", out var f) == true ? Convert.ToDouble(f) : 1.0;
                if (mappedType.Contains("scale")) outputValue = Convert.ToDouble(outputValue) * factor;
                else if (mappedType.Contains("add")) outputValue = Convert.ToDouble(outputValue) + factor;
                else if (mappedType.Contains("multiply")) outputValue = Convert.ToDouble(outputValue) * factor;
                AddConsoleMessage("DEBUG", label, $"Input: {val} → Output: {outputValue}");
                break;
                
            case "Logic":
                var threshold = node.Properties?.TryGetValue("threshold", out var t) == true ? Convert.ToDouble(t) : 50.0;
                var result = Convert.ToDouble(outputValue) > threshold;
                AddConsoleMessage("DEBUG", label, $"Comparing {outputValue} > {threshold} = {result}");
                outputValue = result;
                break;
                
            case "Output":
                if (mappedType.Contains("log") || mappedType.Contains("debug"))
                {
                    AddConsoleMessage("DEBUG", label, $"► {outputValue}");
                }
                else if (mappedType.Contains("notification"))
                {
                    AddConsoleMessage("WARN", label, $"Notification: {outputValue}");
                }
                break;
                
            default:
                AddConsoleMessage("DEBUG", label, $"Executed with value: {outputValue}");
                break;
        }
        
        // Find connected nodes and execute them
        var connectedEdges = CurrentFlow.Edges.Where(e => e.SourceNodeId == node.Id).ToList();
        foreach (var edge in connectedEdges)
        {
            var targetNode = CurrentFlow.Nodes.FirstOrDefault(n => n.Id == edge.TargetNodeId);
            if (targetNode != null)
            {
                await ExecuteNodeFromConfig(targetNode, new Dictionary<string, object> { ["value"] = outputValue });
            }
        }
    }
    
    private double GenerateSimulatedValueFromConfig(FlowNode node)
    {
        var mappedType = MapNodeType(node.Type);
        if (mappedType.Contains("inject") || mappedType.Contains("manual"))
        {
            return DateTime.Now.Second; // Use current second as trigger value
        }
        return Math.Round(new Random().NextDouble() * 100, 2);
    }
    
    private async Task SimulateNodeExecution(Node node, Dictionary<string, object> inputData)
    {
        var label = GetNodeLabel(node);
        var baseType = GetNodeBaseType(node);
        var plugin = NodeRegistry.Get(baseType);
        
        // Simulate processing delay
        await Task.Delay(50);
        
        // Generate output based on node type
        object outputValue = inputData.TryGetValue("value", out var val) ? val : 0.0;
        
        switch (plugin?.Category)
        {
            case "Triggers":
                outputValue = GenerateSimulatedValue(node);
                AddConsoleMessage("INFO", label, $"Triggered with value: {outputValue}");
                break;
                
            case "Tags":
                if (baseType.Contains("input"))
                {
                    // Try to get real tag value from RealtimeDataService
                    if (NodeProperties.TryGetValue(node.ID, out var tagProps) && 
                        tagProps.TryGetValue("tagPath", out var tagPath))
                    {
                        var tagValue = RealtimeData.GetTagValue(tagPath?.ToString() ?? "");
                        if (tagValue != null && tagValue.NumericValue.HasValue)
                        {
                            outputValue = Math.Round(tagValue.NumericValue.Value, 2);
                            AddConsoleMessage("INFO", label, $"Read tag '{tagPath}': {outputValue} (Quality: {tagValue.QualityText})");
                        }
                        else
                        {
                            // Fallback to simulated value if no real data available
                            outputValue = Math.Round(new Random().NextDouble() * 100, 2);
                            AddConsoleMessage("WARN", label, $"No real data for tag '{tagPath}', using simulated: {outputValue}");
                        }
                    }
                    else
                    {
                        outputValue = Math.Round(new Random().NextDouble() * 100, 2);
                        AddConsoleMessage("INFO", label, $"Read tag value (simulated): {outputValue}");
                    }
                }
                else
                {
                    AddConsoleMessage("INFO", label, $"Writing value: {outputValue}");
                }
                break;
                
            case "Math":
                var factor = NodeProperties.TryGetValue(node.ID, out var props) && props.TryGetValue("factor", out var f) ? Convert.ToDouble(f) : 1.0;
                if (baseType.Contains("scale")) outputValue = Convert.ToDouble(outputValue) * factor;
                else if (baseType.Contains("add")) outputValue = Convert.ToDouble(outputValue) + factor;
                else if (baseType.Contains("multiply")) outputValue = Convert.ToDouble(outputValue) * factor;
                AddConsoleMessage("DEBUG", label, $"Input: {val} → Output: {outputValue}");
                break;
                
            case "Logic":
                var threshold = NodeProperties.TryGetValue(node.ID, out var lprops) && lprops.TryGetValue("threshold", out var t) ? Convert.ToDouble(t) : 50.0;
                var result = Convert.ToDouble(outputValue) > threshold;
                AddConsoleMessage("DEBUG", label, $"Comparing {outputValue} > {threshold} = {result}");
                outputValue = result;
                break;
                
            case "Output":
                if (baseType.Contains("debug"))
                {
                    AddConsoleMessage("DEBUG", label, $"► {outputValue}");
                }
                else if (baseType.Contains("notification"))
                {
                    AddConsoleMessage("WARN", label, $"Notification: {outputValue}");
                }
                break;
                
            case "Data Processing":
                AddConsoleMessage("DEBUG", label, $"Processed: {outputValue}");
                break;
                
            default:
                AddConsoleMessage("DEBUG", label, $"Executed with value: {outputValue}");
                break;
        }
        
        // Find connected nodes and execute them
        var outgoingConnectors = Connectors.Where(c => c.SourceID == node.ID).ToList();
        foreach (var connector in outgoingConnectors)
        {
            var targetNode = Nodes.FirstOrDefault(n => n.ID == connector.TargetID);
            if (targetNode != null)
            {
                await SimulateNodeExecution(targetNode, new Dictionary<string, object> { ["value"] = outputValue });
            }
        }
    }
    
    private object GenerateSimulatedValue(Node node)
    {
        var baseType = GetNodeBaseType(node);
        if (baseType.Contains("timer") || baseType.Contains("schedule"))
            return DateTime.Now.ToString("HH:mm:ss");
        if (baseType.Contains("manual"))
            return "Manual Trigger";
        return Math.Round(new Random().NextDouble() * 100, 2);
    }
    
    // Subflow methods
    private async Task CreateSubflowFromSelection()
    {
        if (Diagram == null) return;
        
        var selectedNodes = Nodes.Where(n => Diagram.SelectionSettings?.Nodes?.Any(sn => sn.ID == n.ID) == true).ToList();
        
        if (selectedNodes.Count < 2)
        {
            AddConsoleMessage("WARN", "System", "Select at least 2 nodes to create a subflow");
            return;
        }
        
        // Create subflow definition
        var subflowId = $"subflow-{Guid.NewGuid():N}";
        var subflowName = $"Subflow {ConfigService.Subflows.Count + 1}";
        
        // Find internal connectors (both source and target are in selection)
        var selectedIds = selectedNodes.Select(n => n.ID).ToHashSet();
        var internalConnectors = Connectors.Where(c => selectedIds.Contains(c.SourceID) && selectedIds.Contains(c.TargetID)).ToList();
        
        // Find input/output nodes (connected to nodes outside selection)
        var inputConnectors = Connectors.Where(c => !selectedIds.Contains(c.SourceID) && selectedIds.Contains(c.TargetID)).ToList();
        var outputConnectors = Connectors.Where(c => selectedIds.Contains(c.SourceID) && !selectedIds.Contains(c.TargetID)).ToList();
        
        // Calculate bounding box for relative positions
        var minX = selectedNodes.Min(n => n.OffsetX);
        var minY = selectedNodes.Min(n => n.OffsetY);
        
        var subflow = new SubflowConfig
        {
            Id = subflowId,
            Name = subflowName,
            Description = $"Subflow created from {selectedNodes.Count} nodes",
            InputCount = Math.Max(1, inputConnectors.Select(c => c.TargetPortID).Distinct().Count()),
            OutputCount = Math.Max(1, outputConnectors.Select(c => c.SourcePortID).Distinct().Count()),
            Nodes = selectedNodes.Select(n => new FlowNode
            {
                Id = n.ID,
                Type = GetNodeBaseType(n),
                Label = GetNodeLabel(n),
                X = n.OffsetX - minX,
                Y = n.OffsetY - minY,
                Properties = NodeProperties.TryGetValue(n.ID, out var p) ? p : new()
            }).ToList(),
            Edges = internalConnectors.Select(c => new FlowEdge
            {
                Id = c.ID,
                SourceNodeId = c.SourceID,
                SourcePortId = c.SourcePortID,
                TargetNodeId = c.TargetID,
                TargetPortId = c.TargetPortID
            }).ToList()
        };
        
        await ConfigService.AddSubflowAsync(subflow);
        
        // Register as a node plugin
        NodeRegistry.RegisterSubflow(subflow);
        
        AddConsoleMessage("INFO", "System", $"Created subflow '{subflowName}' with {selectedNodes.Count} nodes");
        
        // Optionally remove selected nodes and replace with subflow node
        ShowReplaceWithSubflowDialog = true;
        PendingSubflowId = subflowId;
    }
    
    private bool ShowReplaceWithSubflowDialog;
    private string PendingSubflowId = "";
    
    private async Task ReplaceSelectionWithSubflow()
    {
        if (Diagram == null || string.IsNullOrEmpty(PendingSubflowId)) return;
        
        var selectedNodes = Nodes.Where(n => Diagram.SelectionSettings?.Nodes?.Any(sn => sn.ID == n.ID) == true).ToList();
        var selectedIds = selectedNodes.Select(n => n.ID).ToHashSet();
        
        // Calculate center position
        var centerX = selectedNodes.Average(n => n.OffsetX);
        var centerY = selectedNodes.Average(n => n.OffsetY);
        
        // Find external connections
        var incomingConnectors = Connectors.Where(c => !selectedIds.Contains(c.SourceID) && selectedIds.Contains(c.TargetID)).ToList();
        var outgoingConnectors = Connectors.Where(c => selectedIds.Contains(c.SourceID) && !selectedIds.Contains(c.TargetID)).ToList();
        
        // Remove selected nodes and their internal connectors
        foreach (var node in selectedNodes)
        {
            Nodes.Remove(node);
            NodeProperties.Remove(node.ID);
        }
        
        var connectorsToRemove = Connectors.Where(c => selectedIds.Contains(c.SourceID) || selectedIds.Contains(c.TargetID)).ToList();
        foreach (var conn in connectorsToRemove)
        {
            Connectors.Remove(conn);
        }
        
        // Add subflow node
        var subflow = ConfigService.Subflows.FirstOrDefault(s => s.Id == PendingSubflowId);
        if (subflow != null)
        {
            var subflowNode = CreateFlowNode(
                $"{PendingSubflowId}-{Guid.NewGuid():N}",
                subflow.Name,
                "#8b5cf6", // Purple for subflows
                centerX, centerY,
                subflow.InputCount, subflow.OutputCount
            );
            Nodes.Add(subflowNode);
            
            // Reconnect external connections
            foreach (var conn in incomingConnectors)
            {
                Connectors.Add(CreateFlowConnector(
                    $"conn-{Guid.NewGuid():N}",
                    conn.SourceID, conn.SourcePortID,
                    subflowNode.ID, "input-0"
                ));
            }
            
            foreach (var conn in outgoingConnectors)
            {
                Connectors.Add(CreateFlowConnector(
                    $"conn-{Guid.NewGuid():N}",
                    subflowNode.ID, "output-0",
                    conn.TargetID, conn.TargetPortID
                ));
            }
        }
        
        ShowReplaceWithSubflowDialog = false;
        PendingSubflowId = "";
        StateHasChanged();
    }
    
    private void EditSubflow(string subflowId)
    {
        var subflow = ConfigService.Subflows.FirstOrDefault(s => s.Id == subflowId);
        if (subflow == null)
        {
            AddConsoleMessage("ERROR", "System", $"Subflow '{subflowId}' not found");
            return;
        }
        
        // Clear current flow and load subflow for editing
        Nodes.Clear();
        Connectors.Clear();
        _pendingConnectors.Clear();
        NodeProperties.Clear();
        _nodeTypes.Clear();
        ConsoleMessages.Clear();
        
        // Set current flow to a temporary editing state for the subflow
        CurrentFlow = new FlowConfig
        {
            Id = subflowId,
            Name = $"Editing Subflow: {subflow.Name}",
            Description = subflow.Description,
            Enabled = false,
            ScanRateMs = 1000
        };
        
        // Load subflow nodes
        foreach (var node in subflow.Nodes)
        {
            var mappedType = MapNodeType(node.Type);
            var plugin = NodeRegistry.Get(mappedType);
            var diagramNode = CreateFlowNode(
                node.Id,
                node.Label ?? plugin?.Name ?? node.Type,
                plugin?.Color ?? "#9ca3af",
                node.X,
                node.Y,
                plugin?.InputCount ?? 1,
                plugin?.OutputCount ?? 1
            );
            Nodes.Add(diagramNode);
            _nodeTypes[node.Id] = mappedType;
            
            if (node.Properties != null)
            {
                NodeProperties[node.Id] = new Dictionary<string, object>(node.Properties);
            }
        }
        
        // Load subflow edges as pending connectors
        foreach (var edge in subflow.Edges)
        {
            var mappedSourcePort = MapPortName(edge.SourcePortId, "output");
            var mappedTargetPort = MapPortName(edge.TargetPortId, "input");
            
            _pendingConnectors.Add(CreateFlowConnector(
                edge.Id,
                edge.SourceNodeId,
                mappedSourcePort,
                edge.TargetNodeId,
                mappedTargetPort
            ));
        }
        
        _connectorsAdded = false;
        _editingSubflowId = subflowId;
        AddConsoleMessage("INFO", "System", $"Editing subflow: {subflow.Name}");
        StateHasChanged();
    }
    
    private string? _editingSubflowId;
    
    private async Task SaveSubflow()
    {
        if (string.IsNullOrEmpty(_editingSubflowId))
        {
            AddConsoleMessage("ERROR", "System", "No subflow being edited");
            return;
        }
        
        var existingSubflow = ConfigService.Subflows.FirstOrDefault(s => s.Id == _editingSubflowId);
        if (existingSubflow == null)
        {
            AddConsoleMessage("ERROR", "System", "Original subflow not found");
            return;
        }
        
        // Update subflow with current diagram state
        existingSubflow.Nodes = Nodes.Select(n => new FlowNode
        {
            Id = n.ID,
            Type = _nodeTypes.TryGetValue(n.ID, out var t) ? t : GetNodeBaseType(n),
            Label = GetNodeLabel(n),
            X = n.OffsetX,
            Y = n.OffsetY,
            Properties = NodeProperties.TryGetValue(n.ID, out var props) 
                ? props.ToDictionary(kv => kv.Key, kv => kv.Value)
                : new Dictionary<string, object>()
        }).ToList();
        
        existingSubflow.Edges = Connectors.Select(c => new FlowEdge
        {
            Id = c.ID,
            SourceNodeId = c.SourceID,
            SourcePortId = c.SourcePortID,
            TargetNodeId = c.TargetID,
            TargetPortId = c.TargetPortID
        }).ToList();
        
        // Calculate input/output counts
        var nodesWithIncoming = Connectors.Select(c => c.TargetID).ToHashSet();
        var nodesWithOutgoing = Connectors.Select(c => c.SourceID).ToHashSet();
        existingSubflow.InputCount = Nodes.Count(n => !nodesWithIncoming.Contains(n.ID));
        existingSubflow.OutputCount = Nodes.Count(n => !nodesWithOutgoing.Contains(n.ID));
        
        await ConfigService.UpdateSubflowAsync(existingSubflow);
        NodeRegistry.UnregisterSubflow(_editingSubflowId);
        NodeRegistry.RegisterSubflow(existingSubflow);
        
        AddConsoleMessage("INFO", "System", $"Saved subflow: {existingSubflow.Name}");
        _editingSubflowId = null;
        
        // Navigate back to flows list
        Navigation.NavigateTo("/flows");
    }
    
    private void CancelSubflowEdit()
    {
        _editingSubflowId = null;
        Nodes.Clear();
        Connectors.Clear();
        _pendingConnectors.Clear();
        NodeProperties.Clear();
        _nodeTypes.Clear();
        ConsoleMessages.Clear();
        Navigation.NavigateTo("/flows");
    }
    
    // Template methods
    private bool ShowTemplateDialog;
    private List<FlowTemplate> AvailableTemplates => ConfigService.FlowTemplates.ToList();
    
    private void ShowTemplates() => ShowTemplateDialog = true;
    
    private async Task ApplyTemplate(FlowTemplate template)
    {
        // Add template nodes to current flow
        var offsetX = Nodes.Any() ? Nodes.Max(n => n.OffsetX) + 300 : 200;
        var offsetY = 150;
        
        foreach (var node in template.Nodes)
        {
            var plugin = NodeRegistry.Get(node.Type);
            var diagramNode = CreateFlowNode(
                $"{node.Type}-{Guid.NewGuid():N}",
                node.Label ?? plugin?.Name ?? node.Type,
                plugin?.Color ?? "#9ca3af",
                node.X + offsetX,
                node.Y + offsetY,
                plugin?.InputCount ?? 1,
                plugin?.OutputCount ?? 1
            );
            Nodes.Add(diagramNode);
            
            if (node.Properties != null)
            {
                NodeProperties[diagramNode.ID] = new Dictionary<string, object>(node.Properties);
            }
        }
        
        // Note: Template edges reference original node IDs, so we'd need to map them
        // For simplicity, user can reconnect after applying template
        
        AddConsoleMessage("INFO", "System", $"Applied template: {template.Name}");
        ShowTemplateDialog = false;
        StateHasChanged();
    }
    
    private async Task SaveAsTemplate()
    {
        if (!Nodes.Any())
        {
            AddConsoleMessage("WARN", "System", "No nodes to save as template");
            return;
        }
        
        var template = new FlowTemplate
        {
            Id = Guid.NewGuid().ToString(),
            Name = $"{CurrentFlow.Name} Template",
            Description = CurrentFlow.Description ?? "Custom template",
            Category = "Custom",
            Nodes = Nodes.Select(n => new FlowNode
            {
                Id = n.ID,
                Type = GetNodeBaseType(n),
                Label = GetNodeLabel(n),
                X = n.OffsetX,
                Y = n.OffsetY,
                Properties = NodeProperties.TryGetValue(n.ID, out var p) ? p : new()
            }).ToList(),
            Edges = Connectors.Select(c => new FlowEdge
            {
                Id = c.ID,
                SourceNodeId = c.SourceID,
                SourcePortId = c.SourcePortID,
                TargetNodeId = c.TargetID,
                TargetPortId = c.TargetPortID
            }).ToList()
        };
        
        await ConfigService.AddFlowTemplateAsync(template);
        AddConsoleMessage("INFO", "System", $"Saved as template: {template.Name}");
    }
    
    public void Dispose()
    {
        _simulationTimer?.Dispose();
        RealtimeData.OnTagValueChanged -= HandleTagValueChanged;
    }

    public class FlowDisplay
    {
        public string Id { get; set; } = "";
        public string Name { get; set; } = "";
        public string Description { get; set; } = "";
        public int NodeCount { get; set; }
        public bool Enabled { get; set; }
    }
    
    public class ConsoleLogMessage
    {
        public DateTime Timestamp { get; set; }
        public string Level { get; set; } = "INFO";
        public string NodeLabel { get; set; } = "";
        public string Message { get; set; } = "";
    }
}
