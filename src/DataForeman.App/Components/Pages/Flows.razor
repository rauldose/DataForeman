@page "/flows"
@page "/flows/{FlowId}"
@rendermode InteractiveServer
@inject ConfigService ConfigService
@inject NodePluginRegistry NodeRegistry
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime
@inject RealtimeDataService RealtimeData
@inject MqttService MqttService
@inject AppStateService AppState
@implements IDisposable

<PageTitle>Flows - DataForeman</PageTitle>

<div class="page-container">
    @if (string.IsNullOrEmpty(FlowId))
    {
        <div class="page-toolbar">
            <h2><i class="fa-solid fa-diagram-project"></i> Flows</h2>
            <div class="toolbar-actions">
                <PermissionGuard Feature="flows" Operation="create">
                    <SfButton CssClass="e-primary" IconCss="fa-solid fa-plus" @onclick="CreateNewFlow">New Flow</SfButton>
                </PermissionGuard>
            </div>
        </div>
        
        @if (!ConfigService.Flows.Any())
        {
            <div class="empty-state">
                <i class="fa-solid fa-diagram-project"></i>
                <span>No flows configured</span>
                <SfButton CssClass="e-primary e-small" @onclick="CreateNewFlow">Create your first flow</SfButton>
            </div>
        }
        else
        {
            <SfGrid DataSource="@FlowsList" AllowPaging="true">
                <GridPageSettings PageSize="10"></GridPageSettings>
                <GridColumns>
                    <GridColumn Field="@nameof(FlowDisplay.Name)" HeaderText="Name" Width="200"></GridColumn>
                    <GridColumn Field="@nameof(FlowDisplay.Description)" HeaderText="Description" Width="300"></GridColumn>
                    <GridColumn Field="@nameof(FlowDisplay.NodeCount)" HeaderText="Nodes" Width="80"></GridColumn>
                    <GridColumn HeaderText="Status" Width="100">
                        <Template>
                            @{
                                var item = (context as FlowDisplay);
                                <span class="status-indicator @(item?.Enabled == true ? "enabled" : "disabled")">
                                    <i class="fa-solid fa-circle"></i> @(item?.Enabled == true ? "Enabled" : "Disabled")
                                </span>
                            }
                        </Template>
                    </GridColumn>
                    <GridColumn HeaderText="Deploy" Width="130">
                        <Template>
                            @{
                                var item = (context as FlowDisplay);
                                if (item != null)
                                {
                                    var flow = ConfigService.Flows.FirstOrDefault(f => f.Id == item.Id);
                                    if (flow != null)
                                    {
                                        var state = RealtimeData.GetFlowDeployState(flow);
                                        @switch (state)
                                        {
                                            case FlowDeployState.Deployed:
                                                <span class="deploy-badge deployed" title="Config matches Engine"><i class="fa-solid fa-circle-check"></i> Deployed</span>
                                                break;
                                            case FlowDeployState.DeployedDisabled:
                                                <span class="deploy-badge deployed-disabled" title="Config matches Engine but flow is disabled"><i class="fa-solid fa-circle-pause"></i> Synced (Off)</span>
                                                break;
                                            case FlowDeployState.Modified:
                                                <span class="deploy-badge modified" title="Local config differs from Engine â€” save and reload to deploy"><i class="fa-solid fa-triangle-exclamation"></i> Modified</span>
                                                break;
                                            default:
                                                <span class="deploy-badge unknown" title="Engine status not available"><i class="fa-solid fa-circle-question"></i> Unknown</span>
                                                break;
                                        }
                                    }
                                }
                            }
                        </Template>
                    </GridColumn>
                    <GridColumn HeaderText="Actions" Width="120">
                        <Template>
                            @{
                                var item = (context as FlowDisplay);
                                <div class="action-buttons">
                                    <SfButton CssClass="e-flat e-small" IconCss="fa-solid fa-pen" @onclick="() => EditFlow(item!.Id)"></SfButton>
                                    <PermissionGuard Feature="flows" Operation="delete">
                                        <SfButton CssClass="e-flat e-small e-danger" IconCss="fa-solid fa-trash" @onclick="() => ConfirmDeleteFlow(item!.Id)"></SfButton>
                                    </PermissionGuard>
                                </div>
                            }
                        </Template>
                    </GridColumn>
                </GridColumns>
            </SfGrid>
        }
    }
    else
    {
        <div class="flow-editor" @key="@FlowId">
            <div class="editor-toolbar">
                <SfButton CssClass="e-flat" IconCss="fa-solid fa-arrow-left" @onclick="GoBack"></SfButton>
                <SfTextBox @bind-Value="CurrentFlow.Name" Placeholder="Flow Name" CssClass="flow-name-input"></SfTextBox>
                <div class="toolbar-spacer"></div>
                @if (!string.IsNullOrEmpty(_editingSubflowId))
                {
                    <span class="editing-subflow-badge"><i class="fa-solid fa-object-group"></i> Editing Subflow</span>
                    <span class="toolbar-separator"></span>
                    <SfButton CssClass="e-info e-outline" IconCss="fa-solid fa-right-to-bracket" Content="+ Input" @onclick="AddSubflowInput" title="Add Subflow Input"></SfButton>
                    <SfButton CssClass="e-info e-outline" IconCss="fa-solid fa-right-from-bracket" Content="+ Output" @onclick="AddSubflowOutput" title="Add Subflow Output"></SfButton>
                    <span class="toolbar-separator"></span>
                    <SfButton CssClass="e-primary" IconCss="fa-solid fa-floppy-disk" @onclick="SaveSubflow">Save Subflow</SfButton>
                    <SfButton CssClass="e-flat" @onclick="CancelSubflowEdit">Cancel</SfButton>
                }
                else
                {
                    <SfButton CssClass="e-flat" IconCss="fa-solid fa-layer-group" Content="Templates" @onclick="ShowTemplates" title="Apply Template"></SfButton>
                    <SfButton CssClass="e-flat" IconCss="fa-solid fa-file-export" @onclick="SaveAsTemplate" title="Save as Template"></SfButton>
                    <SfButton CssClass="e-flat" IconCss="fa-solid fa-object-group" @onclick="CreateSubflowFromSelection" title="Create Subflow from Selection"></SfButton>
                    <SfButton CssClass="@(_showLiveValues ? "e-info" : "e-flat")" IconCss="fa-solid fa-wave-square" Content="Live" @onclick="ToggleLiveValues" title="@(_showLiveValues ? "Hide live port values" : "Show live port values")"></SfButton>
                    <span class="toolbar-separator"></span>
                    <PermissionGuard Feature="flows" Operation="update">
                        <SfButton CssClass="@(CurrentFlow.Enabled ? "e-warning" : "e-success")" 
                                  IconCss="@(CurrentFlow.Enabled ? "fa-solid fa-pause" : "fa-solid fa-play")"
                                  Content="@(CurrentFlow.Enabled ? "Disable" : "Enable")"
                                  @onclick="ToggleEnabled"></SfButton>
                    </PermissionGuard>
                    <span class="@GetDeployBadgeCss()" title="@GetDeployBadgeTooltip()"><i class="@GetDeployBadgeIcon()"></i> @GetDeployBadgeLabel()</span>
                    <PermissionGuard Feature="flows" Operation="update">
                        <SfButton CssClass="e-primary" IconCss="fa-solid fa-floppy-disk" @onclick="SaveFlow">Save</SfButton>
                    </PermissionGuard>
                    <PermissionGuard Feature="flows" Operation="update">
                        <SfButton CssClass="e-info" IconCss="fa-solid fa-rocket" @onclick="DeployFlow" title="Deploy flow to Engine">Deploy</SfButton>
                    </PermissionGuard>
                }
            </div>
            
            <div class="editor-content">
                <div class="node-palette">
                    <div class="palette-header">NODE PALETTE</div>
                    @foreach (var category in NodeRegistry.Categories)
                    {
                        // Only show "Subflow I/O" category when editing a subflow
                        if (category == "Subflow I/O" && string.IsNullOrEmpty(_editingSubflowId))
                            continue;
                        // Hide "Subflow I/O" category in the list when not editing a subflow
                        var plugins = NodeRegistry.GetByCategory(category);
                        if (!plugins.Any()) continue;
                        
                        <div class="palette-category">
                            <div class="category-header" @onclick="() => ToggleCategory(category)">
                                <span class="toggle-icon">@(ExpandedCategories.Contains(category) ? "â–¼" : "â–¶")</span>
                                @category.ToUpperInvariant()
                            </div>
                            @if (ExpandedCategories.Contains(category))
                            {
                                <div class="category-nodes">
                                    @foreach (var plugin in plugins)
                                    {
                                        <div class="palette-node" 
                                             draggable="true"
                                             style="border-left-color: @plugin.Color"
                                             @ondragstart="() => OnPaletteDragStart(plugin)"
                                             @onclick="() => AddNodeFromPalette(plugin)">
                                            <span class="node-icon"><i class="@plugin.Icon" style="color: @plugin.Color"></i></span>
                                            <span class="node-label">@plugin.ShortLabel</span>
                                            @if (category == "Subflows")
                                            {
                                                <span class="subflow-actions" @onclick:stopPropagation="true">
                                                    <button class="subflow-edit-btn" @onclick="() => EditSubflow(plugin.Id)" title="Edit Subflow">
                                                        <i class="fa-solid fa-pen-to-square"></i>
                                                    </button>
                                                </span>
                                            }
                                        </div>
                                    }
                                </div>
                            }
                        </div>
                    }
                </div>
                
                <div class="diagram-container" 
                     id="diagram-space"
                     @ondragover="OnDiagramDragOver"
                     @ondragover:preventDefault="true"
                     @ondrop="OnDiagramDrop"
                     @ondrop:preventDefault="true">
                    <SfDiagramComponent @ref="Diagram" 
                                        ID="diagram"
                                        Width="100%" 
                                        Height="100%"
                                        Nodes="@Nodes"
                                        Connectors="@Connectors"
                                        NodeCreating="@OnNodeCreating"
                                        ConnectorCreating="@OnConnectorCreating"
                                        SelectionChanged="@OnSelectionChanged"
                                        ConnectionChanged="@OnConnectionChanged">
                        <DiagramTemplates>
                            <AnnotationTemplate>
                                @{
                                    var ann = context as ShapeAnnotation;
                                    if (ann?.ID?.StartsWith("lv_") == true)
                                    {
                                        if (!string.IsNullOrEmpty(ann.Content))
                                        {
                                            var textColor = ann.Style?.Color ?? "#e0e0e0";
                                            <div style="background:rgba(30,30,30,0.92);color:@textColor;padding:2px 8px;border-radius:4px;font-size:11px;white-space:nowrap;border:1px solid rgba(255,255,255,0.10);font-family:monospace;">@ann.Content</div>
                                        }
                                    }
                                    else if (ann != null)
                                    {
                                        <span style="color:@(ann.Style?.Color ?? "#fff");font-size:@(ann.Style?.FontSize ?? 12)px;font-weight:@(ann.Style?.Bold == true ? "bold" : "normal");font-style:@(ann.Style?.Italic == true ? "italic" : "normal");">@ann.Content</span>
                                    }
                                }
                            </AnnotationTemplate>
                        </DiagramTemplates>
                        <SnapSettings>
                            <HorizontalGridLines LineColor="#3a4049" LineDashArray="2,4"></HorizontalGridLines>
                            <VerticalGridLines LineColor="#3a4049" LineDashArray="2,4"></VerticalGridLines>
                        </SnapSettings>
                        <ScrollSettings ScrollLimit="ScrollLimitMode.Diagram"></ScrollSettings>
                    </SfDiagramComponent>
                </div>
                
                <div class="properties-panel">
                    <h3>Properties</h3>
                    @if (SelectedNode != null)
                    {
                        var plugin = NodeRegistry.Get(GetNodeType(SelectedNode));
                        <div class="property-header">
                            <span class="node-type-badge" style="border-color: @(plugin?.Color ?? "#9ca3af")">
                                <i class="@(plugin?.Icon ?? "fa-solid fa-question")" style="color: @(plugin?.Color ?? "#9ca3af")"></i>
                                @(plugin?.Name ?? GetNodeType(SelectedNode))
                            </span>
                        </div>
                        
                        @if (plugin != null)
                        {
                            <p class="plugin-description">@plugin.Description</p>
                        }
                        
                        <div class="property-group">
                            <label>Label</label>
                            <SfTextBox Value="@SelectedNodeLabel" ValueChanged="@OnLabelChanged"></SfTextBox>
                        </div>
                        
                        @if (plugin != null)
                        {
                            @foreach (var prop in plugin.Properties.Where(p => !p.Advanced))
                            {
                                <div class="property-group">
                                    <label>@prop.Label @(prop.Required ? "*" : "")</label>
                                    @RenderPropertyInput(prop)
                                    @if (!string.IsNullOrEmpty(prop.HelpText))
                                    {
                                        <span class="property-hint">@prop.HelpText</span>
                                    }
                                </div>
                            }
                        }
                        
                        <div class="property-actions">
                            <SfButton CssClass="e-danger e-small" IconCss="fa-solid fa-trash" @onclick="DeleteSelectedNode">Delete Node</SfButton>
                        </div>
                    }
                    else
                    {
                        <p class="no-selection">Select a node to view properties</p>
                    }
                    
                    <div class="flow-settings">
                        <h4>Flow Settings</h4>
                        <div class="property-group">
                            <label>Description</label>
                            <SfTextBox @bind-Value="CurrentFlow.Description" Multiline="true"></SfTextBox>
                        </div>
                        <div class="property-group">
                            <label>Scan Rate (ms)</label>
                            <SfNumericTextBox TValue="int" @bind-Value="CurrentFlow.ScanRateMs" Min="10" Max="60000"></SfNumericTextBox>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="output-console @(ConsoleExpanded ? "expanded" : "collapsed")">
                <div class="console-header" @onclick="ToggleConsole">
                    <span class="console-toggle"><i class="fa-solid @(ConsoleExpanded ? "fa-chevron-down" : "fa-chevron-up")"></i></span>
                    <span class="console-title"><i class="fa-solid fa-terminal"></i> Output Console</span>
                    <span class="console-badge">@ConsoleMessages.Count</span>
                    <div class="console-actions">
                        <button class="console-btn" @onclick:stopPropagation="true" @onclick="ClearConsole" title="Clear"><i class="fa-solid fa-trash"></i></button>
                    </div>
                </div>
                @if (ConsoleExpanded)
                {
                    <div class="console-body" @ref="ConsoleBody">
                        @if (!ConsoleMessages.Any())
                        {
                            <div class="console-empty">
                                <div>ðŸ“¡ Monitoring real-time tag values</div>
                                <div class="text-muted mt-1">Flows are executed on the Engine. This console shows tag data received via MQTT.</div>
                            </div>
                        }
                        else
                        {
                            @foreach (var msg in ConsoleMessages)
                            {
                                <div class="console-line @msg.Level.ToLower()">
                                    <span class="console-time">@msg.Timestamp.ToString("HH:mm:ss.fff")</span>
                                    <span class="console-level">[@msg.Level]</span>
                                    <span class="console-node">@msg.NodeLabel</span>
                                    <span class="console-text">@msg.Message</span>
                                </div>
                            }
                        }
                    </div>
                }
            </div>
        </div>
    }
</div>

@if (ShowDeleteDialog)
{
    <SfDialog @bind-Visible="ShowDeleteDialog" Width="350px" IsModal="true" ShowCloseIcon="true">
        <DialogTemplates>
            <Header>Confirm Delete</Header>
            <Content>
                <p>Delete this flow?</p>
                <p class="text-muted">This action cannot be undone.</p>
            </Content>
            <FooterTemplate>
                <SfButton @onclick="() => ShowDeleteDialog = false">Cancel</SfButton>
                <SfButton CssClass="e-danger" @onclick="ExecuteDeleteFlow">Delete</SfButton>
            </FooterTemplate>
        </DialogTemplates>
    </SfDialog>
}

@if (ShowTemplateDialog)
{
    <SfDialog @bind-Visible="ShowTemplateDialog" Width="500px" IsModal="true" ShowCloseIcon="true">
        <DialogTemplates>
            <Header><i class="fa-solid fa-layer-group"></i> Flow Templates</Header>
            <Content>
                @if (!AvailableTemplates.Any())
                {
                    <p class="text-muted">No templates available. Save a flow as template first.</p>
                }
                else
                {
                    <div class="template-list">
                        @foreach (var template in AvailableTemplates)
                        {
                            <div class="template-card" @onclick="() => ApplyTemplate(template)">
                                <div class="template-name"><i class="fa-solid fa-file-code"></i> @template.Name</div>
                                <div class="template-description">@template.Description</div>
                                <div class="template-meta">
                                    <span class="template-category">@template.Category</span>
                                    <span class="template-nodes">@template.Nodes.Count nodes</span>
                                </div>
                            </div>
                        }
                    </div>
                }
            </Content>
            <FooterTemplate>
                <SfButton @onclick="() => ShowTemplateDialog = false">Close</SfButton>
            </FooterTemplate>
        </DialogTemplates>
    </SfDialog>
}

@if (ShowReplaceWithSubflowDialog)
{
    <SfDialog @bind-Visible="ShowReplaceWithSubflowDialog" Width="400px" IsModal="true" ShowCloseIcon="true">
        <DialogTemplates>
            <Header><i class="fa-solid fa-object-group"></i> Subflow Created</Header>
            <Content>
                <p>Subflow has been created and added to the palette.</p>
                <p>Would you like to replace the selected nodes with the new subflow node?</p>
            </Content>
            <FooterTemplate>
                <SfButton @onclick="() => { ShowReplaceWithSubflowDialog = false; PendingSubflowId = string.Empty; }">Keep Nodes</SfButton>
                <SfButton CssClass="e-primary" @onclick="ReplaceSelectionWithSubflow">Replace with Subflow</SfButton>
            </FooterTemplate>
        </DialogTemplates>
    </SfDialog>
}

@code {
    [Parameter] public string? FlowId { get; set; }
    
    private SfDiagramComponent? Diagram;
    private DiagramObjectCollection<Node> Nodes = new();
    private DiagramObjectCollection<Connector> Connectors = new();
    private Node? SelectedNode;
    private string SelectedNodeLabel = "";
    
    // Palette state
     private HashSet<string> ExpandedCategories = new() { "Triggers", "Tags" };
    private NodePluginDefinition? _draggingPlugin;
    
    private FlowConfig CurrentFlow = new();
    private bool ShowDeleteDialog;
    private string DeleteFlowId = "";
    private string? _lastLoadedFlowId;
    
    // Disposal flag to stop execution when navigating away
    private bool _disposed = false;
    private CancellationTokenSource? _cts;
    
    // MISSING FIELDS ADDED HERE:
    private string? _editingSubflowId;
    private bool ShowTemplateDialog;
    private bool ShowReplaceWithSubflowDialog;
    private string PendingSubflowId = "";
    private List<FlowTemplate> AvailableTemplates => ConfigService.FlowTemplates.ToList();

    private List<FlowTagPathOption> _flowTagPathOptions = new();
    private List<FlowTagPathOption> FlowTagPathOptions => _flowTagPathOptions;
    
    // Node property values storage
    private Dictionary<string, Dictionary<string, object>> NodeProperties = new();
    
    // Node type mapping (for looking up plugin info)
    private Dictionary<string, string> _nodeTypes = new();
    
    // Pending connectors (added after diagram is rendered)
    private DiagramObjectCollection<Connector> _pendingConnectors = new();
    private bool _connectorsAdded = false;
    
    // Output Console
    private bool ConsoleExpanded = true;
    private List<ConsoleLogMessage> ConsoleMessages = new();
    private ElementReference ConsoleBody;
    private System.Timers.Timer? _simulationTimer;

    // Live value annotations on diagram node ports
    private bool _showLiveValues = false;
    // Per-node live port data: nodeId -> { inputText, outputText }
    private Dictionary<string, (string InputText, string OutputText)> _livePortValues = new();

    private List<FlowDisplay> FlowsList => ConfigService.Flows.Select(f => new FlowDisplay
    {
        Id = f.Id,
        Name = f.Name,
        Description = f.Description ?? "",
        NodeCount = f.Nodes.Count,
        Enabled = f.Enabled
    }).ToList();

    protected override async Task OnInitializedAsync()
    {
        _cts = new CancellationTokenSource();
        _disposed = false; // Reset in case component is reused
        await ConfigService.LoadAllAsync();
        _flowTagPathOptions = ConfigService.GetAllTagsWithConnection()
            .Select(t => new FlowTagPathOption
            {
                Path = $"{t.Connection.Name}/{t.Tag.Name}",
                Label = $"{t.Connection.Name} / {t.Tag.Name}"
            })
            .OrderBy(t => t.Label)
            .ToList();
        RealtimeData.OnTagValueChanged += HandleTagValueChanged;
        RealtimeData.OnFlowExecutionReceived += HandleFlowExecutionReceived;
        RealtimeData.OnFlowDeployStatusChanged += HandleDeployStatusChanged;
        RealtimeData.OnFlowRunSummaryReceived += HandleFlowRunSummary;
    }

    protected override async Task OnParametersSetAsync()
    {
        // Handle parameter changes (navigating between flows)
        if (FlowId != _lastLoadedFlowId)
        {
            _lastLoadedFlowId = FlowId;
            
            if (!string.IsNullOrEmpty(FlowId) && FlowId != "new")
            {
                var flow = ConfigService.Flows.FirstOrDefault(f => f.Id == FlowId);
                if (flow != null)
                {
                    CurrentFlow = flow;
                    
                    // Reset state before loading
                    _connectorsAdded = false; 
                    
                    LoadFlowDefinition(flow);
                    
                    ConsoleMessages.Clear();
                    AddConsoleMessage("INFO", "System", $"Loaded flow: {flow.Name}");
                    StateHasChanged();
                }
            }
            else if (FlowId == "new")
            {
                CurrentFlow = new FlowConfig { Name = "New Flow" };
                // FIX: Create new instances instead of Clear()
                Nodes = new DiagramObjectCollection<Node>();
                Connectors = new DiagramObjectCollection<Connector>();
                _pendingConnectors.Clear();
                NodeProperties.Clear();
                _nodeTypes.Clear();
                ConsoleMessages.Clear();
                StateHasChanged();
            }
            else
            {
                // Returning to flow list - clear state with new instances
                Nodes = new DiagramObjectCollection<Node>();
                Connectors = new DiagramObjectCollection<Connector>();
                _pendingConnectors.Clear();
            }
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Add connectors after nodes are fully rendered
        if (!_connectorsAdded && Diagram != null && _pendingConnectors.Count > 0)
        {
            _connectorsAdded = true;
            
            // Wait for nodes to be fully rendered
            await Task.Delay(500);
            
            try
            {
                var connectorsToAdd = _pendingConnectors.ToList();
                await Diagram.AddDiagramElementsAsync(new DiagramObjectCollection<NodeBase>(connectorsToAdd.Cast<NodeBase>()));
                _pendingConnectors.Clear();
                Console.WriteLine($"Successfully added {connectorsToAdd.Count} connectors");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to add connectors: {ex.Message}");
            }
        }
    }
    
    private async void HandleTagValueChanged(string tagId)
    {
        // Stop if component is disposed (user navigated away)
        if (_disposed || _cts?.IsCancellationRequested == true) return;
        
        try
        {
            // NOTE: Flow execution happens on the ENGINE, not here.
            // This handler only updates the visual display when tag values change.
            
            // Find nodes that use this tag and update their display
            foreach (var nodeEntry in NodeProperties)
            {
                if (_disposed || _cts?.IsCancellationRequested == true) return;
                
                if (nodeEntry.Value.TryGetValue("tagPath", out var tagPath) && 
                    tagPath?.ToString() == tagId)
                {
                    var tagValue = RealtimeData.GetTagValue(tagId);
                    if (tagValue != null)
                    {
                        // Just show the value in console - no execution on frontend
                        var node = Nodes.FirstOrDefault(n => n.ID == nodeEntry.Key);
                        if (node != null)
                        {
                            var label = GetNodeLabel(node);
                            var value = tagValue.NumericValue ?? tagValue.Value ?? 0.0;
                            AddConsoleMessage("DATA", label, $"Value: {value:F2} (Quality: {tagValue.Quality})");
                        }
                        
                        if (!_disposed && _cts?.IsCancellationRequested != true)
                        {
                            await InvokeAsync(StateHasChanged);
                        }
                    }
                }
            }
        }
        catch (OperationCanceledException)
        {
            // Expected when cancelled during navigation
        }
        catch (ObjectDisposedException)
        {
            // Component was disposed
        }
    }

    private async void HandleFlowExecutionReceived(DataForeman.Shared.Messages.FlowExecutionMessage message)
    {
        try
        {
            if (_disposed || _cts?.IsCancellationRequested == true) return;
            
            // Only show messages for the current flow
            if (CurrentFlow != null && message.FlowId == CurrentFlow.Id)
            {
                // Find the node label
                var nodeLabel = message.NodeId;
                var node = Nodes.FirstOrDefault(n => n.ID == message.NodeId);
                if (node != null)
                {
                    nodeLabel = GetNodeLabel(node);
                }

                // Format the message
                var msgText = message.Message;
                if (message.InputData?.Any() == true)
                {
                    var inputStr = string.Join(", ", message.InputData.Select(kv => $"{kv.Key}={FormatSingleValue(kv.Value)}"));
                    msgText += $" | Input: {inputStr}";
                }
                if (message.OutputData?.Any() == true)
                {
                    var outputStr = string.Join(", ", message.OutputData.Select(kv => $"{kv.Key}={FormatSingleValue(kv.Value)}"));
                    msgText += $" | Output: {outputStr}";
                }

                AddConsoleMessage(message.Level, nodeLabel, msgText);

                // Update live value annotations on diagram node ports
                if (_showLiveValues && node != null)
                {
                    var inputText = message.InputData?.Any() == true ? FormatLiveValue(message.InputData) : null;
                    var outputText = message.OutputData?.Any() == true ? FormatLiveValue(message.OutputData) : null;
                    var isError = message.Level == "ERROR";

                    if (isError && outputText == null)
                        outputText = "ERR";

                    // Merge with existing port data (accumulate across executions)
                    if (_livePortValues.TryGetValue(message.NodeId, out var existing))
                    {
                        inputText ??= existing.InputText;
                        outputText ??= existing.OutputText;
                    }

                    _livePortValues[message.NodeId] = (inputText ?? "", outputText ?? "");
                    UpdatePortAnnotations(node, inputText ?? "", outputText ?? "", isError);
                }
                
                if (!_disposed && _cts?.IsCancellationRequested != true)
                {
                    await InvokeAsync(StateHasChanged);
                }
            }
        }
        catch (OperationCanceledException)
        {
            // Expected when cancelled during navigation
        }
        catch (ObjectDisposedException)
        {
            // Component was disposed
        }
    }

    private async void HandleDeployStatusChanged(string flowId)
    {
        try
        {
            if (_disposed || _cts?.IsCancellationRequested == true) return;
            await InvokeAsync(StateHasChanged);
        }
        catch (ObjectDisposedException) { }
        catch (OperationCanceledException) { }
    }

    private void HandleFlowRunSummary(FlowRunSummaryMessage summary)
    {
        try
        {
            if (_disposed || _cts?.IsCancellationRequested == true) return;
            if (FlowId != "new" && summary.FlowId == FlowId)
            {
                var level = summary.Outcome == "Success" ? "info" : "error";
                var msg = $"{summary.Outcome}: {summary.NodesExecuted} nodes, {summary.DurationMs:F0}ms";
                if (!string.IsNullOrEmpty(summary.ErrorDetail))
                    msg += $" â€” {summary.ErrorDetail}";
                AddConsoleMessage(level, summary.TriggerTopic ?? "Engine", msg);
            }
        }
        catch (ObjectDisposedException) { }
    }

    private void LoadFlowDefinition(FlowConfig flow)
    {
        // FIX: New collection instances
        Nodes = new DiagramObjectCollection<Node>();
        Connectors = new DiagramObjectCollection<Connector>();
        
        _pendingConnectors.Clear();
        NodeProperties.Clear();
        _nodeTypes.Clear();
        
        foreach (var node in flow.Nodes)
        {
            var mappedType = MapNodeType(node.Type);
            var plugin = NodeRegistry.Get(mappedType);
            var diagramNode = CreateFlowNode(
                node.Id,
                node.Label ?? plugin?.Name ?? node.Type,
                plugin?.Color ?? "#9ca3af",
                node.X,
                node.Y,
                plugin?.InputCount ?? 1,
                plugin?.OutputCount ?? 1
            );
            Nodes.Add(diagramNode);
            _nodeTypes[node.Id] = mappedType;
            
            if (node.Properties != null)
            {
                NodeProperties[node.Id] = new Dictionary<string, object>(node.Properties);
            }
        }
        
        foreach (var edge in flow.Edges)
        {
            var mappedSourcePort = MapPortName(edge.SourcePortId, "output");
            var mappedTargetPort = MapPortName(edge.TargetPortId, "input");
            
            _pendingConnectors.Add(CreateFlowConnector(
                edge.Id,
                edge.SourceNodeId,
                mappedSourcePort,
                edge.TargetNodeId,
                mappedTargetPort
            ));
        }
        
        _connectorsAdded = false;
    }

    private string MapNodeType(string? nodeType)
    {
        if (string.IsNullOrEmpty(nodeType)) return "unknown";
        if (NodeRegistry.Get(nodeType) != null) return nodeType;
        
        return nodeType.ToLower() switch
        {
            "taginput" => "tag-input",
            "tagoutput" => "tag-output",
            "compare" => "logic-compare",
            "debug" => "output-log",
            "notification" => "output-notification",
            "timer" => "trigger-schedule",
            "inject" => "trigger-manual",
            "multiply" => "math-multiply",
            "divide" => "math-divide",
            "add" => "math-add",
            "subtract" => "math-subtract",
            "scale" => "math-scale",
            "smooth" => "data-smooth",
            "mqttin" => "mqtt-in",
            "mqttout" => "mqtt-out",
            "template" => "func-template",
            "switch" => "func-switch",
            "branch" => "logic-branch",
            "and" => "logic-and",
            "or" => "logic-or",
            "delay" => "util-delay",
            "filter" => "util-filter",
            "constant" => "util-constant",
            "aggregate" => "data-aggregate",
            "deadband" => "data-deadband",
            "rateofchange" => "data-rateofchange",
            "httprequest" => "http-request",
            "javascript" => "func-javascript",
            _ => nodeType.ToLower()
        };
    }

    private string MapPortName(string? portName, string portType)
    {
        if (string.IsNullOrEmpty(portName)) return $"{portType}-0";
        if (portName.StartsWith("input-") || portName.StartsWith("output-")) return portName;
        if (portName.Equals("input", StringComparison.OrdinalIgnoreCase) || portName.Equals("output", StringComparison.OrdinalIgnoreCase)) return $"{portType}-0";
        if (portName.Equals("true", StringComparison.OrdinalIgnoreCase)) return "output-0";
        if (portName.Equals("false", StringComparison.OrdinalIgnoreCase)) return "output-1";
        if (portName.StartsWith("input", StringComparison.OrdinalIgnoreCase) && portName.Length > 5 && int.TryParse(portName[5..], out var inputNum)) return $"input-{inputNum - 1}";
        if (portName.StartsWith("output", StringComparison.OrdinalIgnoreCase) && portName.Length > 6 && int.TryParse(portName[6..], out var outputNum)) return $"output-{outputNum - 1}";
        return $"{portType}-0";
    }

    private FlowDeployState CurrentDeployState => FlowId != "new" ? RealtimeData.GetFlowDeployState(CurrentFlow) : FlowDeployState.Unknown;

    private string GetDeployBadgeCss() => CurrentDeployState switch
    {
        FlowDeployState.Deployed => "deploy-badge deployed",
        FlowDeployState.DeployedDisabled => "deploy-badge deployed-disabled",
        FlowDeployState.Modified => "deploy-badge modified",
        _ => "deploy-badge unknown"
    };

    private string GetDeployBadgeIcon() => CurrentDeployState switch
    {
        FlowDeployState.Deployed => "fa-solid fa-circle-check",
        FlowDeployState.DeployedDisabled => "fa-solid fa-circle-pause",
        FlowDeployState.Modified => "fa-solid fa-triangle-exclamation",
        _ => "fa-solid fa-circle-question"
    };

    private string GetDeployBadgeLabel() => CurrentDeployState switch
    {
        FlowDeployState.Deployed => "Deployed",
        FlowDeployState.DeployedDisabled => "Synced (Off)",
        FlowDeployState.Modified => "Modified",
        _ => "Not Deployed"
    };

    private string GetDeployBadgeTooltip() => CurrentDeployState switch
    {
        FlowDeployState.Deployed => "In sync with Engine",
        FlowDeployState.DeployedDisabled => "Config matches Engine but flow is disabled",
        FlowDeployState.Modified => "Local config differs from Engine â€” save and reload to deploy",
        _ => "Engine status not available"
    };

    private void CreateNewFlow() => Navigation.NavigateTo("/flows/new");
    private void EditFlow(string id) => Navigation.NavigateTo($"/flows/{id}");
    private void GoBack() => Navigation.NavigateTo("/flows");
    private void ToggleEnabled() => CurrentFlow.Enabled = !CurrentFlow.Enabled;

    private async Task SaveFlow()
    {
        CurrentFlow.Nodes = Nodes.Where(n => !string.IsNullOrEmpty(n.ID)).Select(n => new FlowNode
        {
            Id = n.ID,
            Type = GetNodeType(n),
            Label = GetNodeLabel(n),
            X = n.OffsetX,
            Y = n.OffsetY,
            Properties = NodeProperties.TryGetValue(n.ID, out var props) ? props : new()
        }).ToList();
        
        CurrentFlow.Edges = Connectors.Where(c => !string.IsNullOrEmpty(c.ID)).Select(c => new FlowEdge
        {
            Id = c.ID,
            SourceNodeId = c.SourceID,
            SourcePortId = c.SourcePortID,
            TargetNodeId = c.TargetID,
            TargetPortId = c.TargetPortID
        }).ToList();
        
        CurrentFlow.UpdatedAt = DateTime.UtcNow;
        
        if (FlowId == "new") await ConfigService.AddFlowAsync(CurrentFlow);
        else await ConfigService.UpdateFlowAsync(CurrentFlow);
        
        if (FlowId == "new")
            Navigation.NavigateTo($"/flows/{CurrentFlow.Id}", replace: true);

        if (DataForeman.App.Components.Layout.MainLayout.Instance is { } layout)
            await layout.ShowToastAsync("Flow saved", "e-toast-success", "Saved");
    }

    private async Task DeployFlow()
    {
        // Save first, then tell the Engine to reload
        await SaveFlow();
        await MqttService.PublishConfigReloadAsync("flows");
        
        if (DataForeman.App.Components.Layout.MainLayout.Instance is { } layout)
            await layout.ShowToastAsync("Deploy command sent to Engine", "e-toast-info", "Deploying");
    }

    private void ConfirmDeleteFlow(string id) { DeleteFlowId = id; ShowDeleteDialog = true; }
    private async Task ExecuteDeleteFlow() { await ConfigService.DeleteFlowAsync(DeleteFlowId); ShowDeleteDialog = false; }

    private void ToggleCategory(string category) { if (ExpandedCategories.Contains(category)) ExpandedCategories.Remove(category); else ExpandedCategories.Add(category); }
    private void OnPaletteDragStart(NodePluginDefinition plugin) { _draggingPlugin = plugin; }
    private void OnDiagramDragOver(Microsoft.AspNetCore.Components.Web.DragEventArgs e) { e.DataTransfer.DropEffect = "copy"; }

    private async Task OnDiagramDrop(Microsoft.AspNetCore.Components.Web.DragEventArgs e)
    {
        if (_draggingPlugin == null || Diagram == null) return;
        try
        {
            var diagramRect = await JSRuntime.InvokeAsync<Dictionary<string, double>>("eval", "(() => { const rect = document.getElementById('diagram-space').getBoundingClientRect(); return { left: rect.left, top: rect.top }; })()");
            double diagramX = e.ClientX - diagramRect["left"];
            double diagramY = e.ClientY - diagramRect["top"];
            await AddNodeFromPalette(_draggingPlugin, diagramX, diagramY);
        }
        finally { _draggingPlugin = null; }
    }

    private async Task AddNodeFromPalette(NodePluginDefinition plugin, double? x = null, double? y = null)
    {
        if (Diagram == null) return;
        double offsetX = x ?? (400 + (Nodes.Count % 4) * 220);
        double offsetY = y ?? (150 + (Nodes.Count / 4) * 120);
        
        var nodeId = $"{plugin.Id}-{Guid.NewGuid():N}";
        var node = CreateFlowNode(nodeId, plugin.Name, plugin.Color, offsetX, offsetY, plugin.InputCount, plugin.OutputCount);
        
        NodeProperties[nodeId] = plugin.Properties.Where(p => !string.IsNullOrEmpty(p.DefaultValue)).ToDictionary(p => p.Key, p => (object)p.DefaultValue);
        Nodes.Add(node);
        StateHasChanged();
    }

    private Node CreateFlowNode(string id, string label, string color, double x, double y, int inputCount, int outputCount)
    {
        var baseType = GetNodeType(id);
        var plugin = NodeRegistry.Get(baseType);
        
        var node = new Node
        {
            ID = id, OffsetX = x, OffsetY = y, Width = 180, Height = 70,
            Shape = new BasicShape { Type = NodeShapes.Basic, Shape = NodeBasicShapes.Rectangle, CornerRadius = 8 },
            Style = new ShapeStyle { Fill = "#2a2a2a", StrokeColor = color, StrokeWidth = 2 },
            Annotations = new DiagramObjectCollection<ShapeAnnotation>(), Ports = new DiagramObjectCollection<PointPort>(),
            Constraints = NodeConstraints.Default | NodeConstraints.AllowDrop
        };
        
        // Annotations[0] = node name, [1] = category
        node.Annotations.Add(new ShapeAnnotation { Content = label, Style = new TextStyle { Color = "#ffffff", FontSize = 13, Bold = true }, Offset = new DiagramPoint { X = 0.5, Y = 0.35 }, HorizontalAlignment = HorizontalAlignment.Center });
        node.Annotations.Add(new ShapeAnnotation { Content = plugin?.Category ?? "Node", Style = new TextStyle { Color = "#9d9d9d", FontSize = 10, Italic = true }, Offset = new DiagramPoint { X = 0.5, Y = 0.7 }, HorizontalAlignment = HorizontalAlignment.Center });
        
        for (int i = 0; i < inputCount; i++)
        {
            var yOffset = inputCount == 1 ? 0.5 : (i + 1.0) / (inputCount + 1);
            node.Ports.Add(new PointPort { ID = $"input-{i}", Offset = new DiagramPoint { X = 0, Y = yOffset }, Visibility = PortVisibility.Visible, Shape = PortShapes.Circle, Width = 12, Height = 12, Style = new ShapeStyle { Fill = "#3b82f6", StrokeColor = "#ffffff", StrokeWidth = 2 }, Constraints = PortConstraints.Default | PortConstraints.Draw });
        }
        
        for (int i = 0; i < outputCount; i++)
        {
            var yOffset = outputCount == 1 ? 0.5 : (i + 1.0) / (outputCount + 1);
            node.Ports.Add(new PointPort { ID = $"output-{i}", Offset = new DiagramPoint { X = 1, Y = yOffset }, Visibility = PortVisibility.Visible, Shape = PortShapes.Circle, Width = 12, Height = 12, Style = new ShapeStyle { Fill = "#f59e0b", StrokeColor = "#ffffff", StrokeWidth = 2 }, Constraints = PortConstraints.Default | PortConstraints.Draw });
        }
        
        // Annotations[2..2+inputCount-1] = input port live values (pre-created with empty content)
        for (int i = 0; i < inputCount; i++)
        {
            var yOffset = inputCount == 1 ? 0.5 : (i + 1.0) / (inputCount + 1);
            node.Annotations.Add(new ShapeAnnotation
            {
                ID = $"lv_in_{i}",
                Content = "",
                Style = new TextStyle { Color = "#e0e0e0", FontSize = 11 },
                Offset = new DiagramPoint { X = 0, Y = yOffset },
                HorizontalAlignment = HorizontalAlignment.Right,
                Margin = new DiagramThickness { Right = 15 }
            });
        }
        
        // Output port live values start at annotation index 2+inputCount
        for (int i = 0; i < outputCount; i++)
        {
            var yOffset = outputCount == 1 ? 0.5 : (i + 1.0) / (outputCount + 1);
            node.Annotations.Add(new ShapeAnnotation
            {
                ID = $"lv_out_{i}",
                Content = "",
                Style = new TextStyle { Color = "#e0e0e0", FontSize = 11 },
                Offset = new DiagramPoint { X = 1, Y = yOffset },
                HorizontalAlignment = HorizontalAlignment.Left,
                Margin = new DiagramThickness { Left = 15 }
            });
        }
        
        return node;
    }

    private Connector CreateFlowConnector(string id, string sourceId, string? sourcePort, string targetId, string? targetPort)
    {
        return new Connector
        {
            ID = id, SourceID = sourceId, SourcePortID = sourcePort ?? "output-0", TargetID = targetId, TargetPortID = targetPort ?? "input-0",
            Type = ConnectorSegmentType.Orthogonal, Style = new ShapeStyle { StrokeColor = "#4caf50", StrokeWidth = 2 }, CornerRadius = 5,
            TargetDecorator = new DecoratorSettings { Shape = DecoratorShape.Arrow, Width = 10, Height = 10, Style = new ShapeStyle { Fill = "#4caf50", StrokeColor = "#4caf50" } }
        };
    }

    private void OnNodeCreating(IDiagramObject obj) { if (obj is Node node) { node.Style.Fill = "#2a2a2a"; if (node.Ports != null) foreach (var port in node.Ports) { port.Visibility = PortVisibility.Visible; port.Width = 12; port.Height = 12; port.Constraints = PortConstraints.Default | PortConstraints.Draw; } } }
    private void OnConnectorCreating(IDiagramObject obj) { if (obj is Connector connector) { connector.Type = ConnectorSegmentType.Orthogonal; connector.Style = new ShapeStyle { StrokeColor = "#4caf50", StrokeWidth = 2 }; connector.CornerRadius = 5; connector.TargetDecorator = new DecoratorSettings { Shape = DecoratorShape.Arrow, Width = 10, Height = 10, Style = new ShapeStyle { Fill = "#4caf50", StrokeColor = "#4caf50" } }; } }

    private void OnConnectionChanged(Syncfusion.Blazor.Diagram.ConnectionChangedEventArgs args)
    {
        if (args.Connector != null && !string.IsNullOrEmpty(args.Connector.SourceID) && !string.IsNullOrEmpty(args.Connector.TargetID))
        {
            var sourceNode = Nodes.FirstOrDefault(n => n.ID == args.Connector.SourceID);
            var targetNode = Nodes.FirstOrDefault(n => n.ID == args.Connector.TargetID);
            AddConsoleMessage("INFO", "System", $"Connected: {(sourceNode != null ? GetNodeLabel(sourceNode) : args.Connector.SourceID)} â†’ {(targetNode != null ? GetNodeLabel(targetNode) : args.Connector.TargetID)}");
        }
    }

    private void OnSelectionChanged(Syncfusion.Blazor.Diagram.SelectionChangedEventArgs args)
    {
        if (args.NewValue?.Count > 0 && args.NewValue[0] is Node node) { SelectedNode = node; SelectedNodeLabel = GetNodeLabel(node); }
        else { SelectedNode = null; SelectedNodeLabel = ""; }
    }

    private async Task OnLabelChanged(string newLabel)
    {
        if (SelectedNode == null || Diagram == null) return;
        SelectedNodeLabel = newLabel;
        if (SelectedNode.Annotations.Count > 0) { SelectedNode.Annotations[0].Content = newLabel; StateHasChanged(); }
    }

    private async Task DeleteSelectedNode()
    {
        if (SelectedNode == null || Diagram == null) return;
        var nodeId = SelectedNode.ID;
        Nodes.Remove(SelectedNode);
        NodeProperties.Remove(nodeId);
        var connectedConnectors = Connectors.Where(c => c.SourceID == nodeId || c.TargetID == nodeId).ToList();
        foreach (var conn in connectedConnectors) Connectors.Remove(conn);
        SelectedNode = null;
        StateHasChanged();
    }

    private string GetNodeLabel(Node node) => node?.Annotations?.FirstOrDefault()?.Content ?? node?.ID ?? "Unknown";
    
    /// <summary>
    /// Extracts the plugin type ID from a node ID (e.g., "tag-input-instance-abc123" â†’ "tag-input")
    /// </summary>
    private string GetNodeType(string? nodeId)
    {
        if (string.IsNullOrEmpty(nodeId)) return "unknown";
        if (nodeId.Contains("-instance-")) return nodeId.Split("-instance-")[0];
        var parts = nodeId.Split('-');
        for (int i = parts.Length; i > 0; i--) { var candidate = string.Join("-", parts.Take(i)); if (NodeRegistry.Get(candidate) != null) return candidate; }
        if (parts.Length > 1 && parts[^1].Length >= 8) return string.Join("-", parts.Take(parts.Length - 1));
        return nodeId;
    }
    
    private string GetNodeType(Node? node) => GetNodeType(node?.ID);
    
    /// <summary>
    /// Safely converts an object to double, handling JsonElement and other types.
    /// </summary>
    private double ToDouble(object? value, double defaultValue = 0.0)
    {
        if (value == null) return defaultValue;
        if (value is double d) return d;
        if (value is int i) return i;
        if (value is float f) return f;
        if (value is decimal dec) return (double)dec;
        if (value is long l) return l;
        if (value is System.Text.Json.JsonElement je)
        {
            return je.ValueKind switch
            {
                System.Text.Json.JsonValueKind.Number => je.GetDouble(),
                System.Text.Json.JsonValueKind.String when double.TryParse(je.GetString(), out var parsed) => parsed,
                _ => defaultValue
            };
        }
        if (value is string s && double.TryParse(s, out var result)) return result;
        try { return Convert.ToDouble(value); } catch { return defaultValue; }
    }

    private RenderFragment RenderPropertyInput(NodePropertyDefinition prop) => builder =>
    {
        var nodeId = SelectedNode?.ID;
        if (nodeId == null) return;
        if (!NodeProperties.ContainsKey(nodeId)) NodeProperties[nodeId] = new();
        var currentValue = NodeProperties[nodeId].TryGetValue(prop.Key, out var v) ? v?.ToString() : prop.DefaultValue;
        
        switch (prop.Type)
        {
            case PropertyType.Text:
                builder.OpenComponent<SfTextBox>(0); builder.AddAttribute(1, "Value", currentValue ?? ""); builder.AddAttribute(2, "ValueChanged", EventCallback.Factory.Create<string>(this, val => SetPropertyValue(nodeId, prop.Key, val))); builder.AddAttribute(3, "Placeholder", prop.Placeholder); builder.CloseComponent(); break;
            case PropertyType.Integer:
                builder.OpenComponent<SfNumericTextBox<int>>(0); builder.AddAttribute(1, "Value", int.TryParse(currentValue, out var intVal) ? intVal : 0); builder.AddAttribute(2, "ValueChanged", EventCallback.Factory.Create<int>(this, val => SetPropertyValue(nodeId, prop.Key, val.ToString()))); builder.AddAttribute(3, "Min", (int)(prop.Min ?? int.MinValue)); builder.AddAttribute(4, "Max", (int)(prop.Max ?? int.MaxValue)); builder.CloseComponent(); break;
            case PropertyType.Decimal:
                builder.OpenComponent<SfNumericTextBox<double>>(0); builder.AddAttribute(1, "Value", double.TryParse(currentValue, out var dblVal) ? dblVal : 0); builder.AddAttribute(2, "ValueChanged", EventCallback.Factory.Create<double>(this, val => SetPropertyValue(nodeId, prop.Key, val.ToString()))); builder.CloseComponent(); break;
            case PropertyType.Boolean:
                builder.OpenComponent<SfCheckBox<bool>>(0); builder.AddAttribute(1, "Checked", currentValue?.ToLower() == "true"); builder.AddAttribute(2, "CheckedChanged", EventCallback.Factory.Create<bool>(this, val => SetPropertyValue(nodeId, prop.Key, val.ToString().ToLower()))); builder.CloseComponent(); break;
            case PropertyType.TagPath:
                var tagOpts = FlowTagPathOptions;
                builder.OpenComponent<SfDropDownList<string, FlowTagPathOption>>(0);
                builder.AddAttribute(1, "Value", currentValue ?? "");
                builder.AddAttribute(2, "ValueChanged", EventCallback.Factory.Create<string>(this, val => SetPropertyValue(nodeId, prop.Key, val)));
                builder.AddAttribute(3, "DataSource", tagOpts);
                builder.AddAttribute(4, "Placeholder", "Select tag...");
                builder.AddAttribute(5, "AllowFiltering", true);
                builder.AddAttribute(6, "ChildContent", (RenderFragment)(b2 =>
                {
                    b2.OpenComponent<DropDownListFieldSettings>(0);
                    b2.AddAttribute(1, "Text", "Label");
                    b2.AddAttribute(2, "Value", "Path");
                    b2.CloseComponent();
                }));
                builder.CloseComponent();
                break;
            case PropertyType.Code:
                var codeVal = currentValue ?? prop.DefaultValue ?? "";
                var codeNodeId = nodeId;
                var codePropKey = prop.Key;
                builder.OpenComponent<CSharpEditor>(0);
                builder.AddAttribute(1, "Code", codeVal);
                builder.AddAttribute(2, "CodeChanged", EventCallback.Factory.Create<string>(this, val => SetPropertyValue(codeNodeId, codePropKey, val)));
                builder.AddAttribute(3, "Label", prop.Label);
                builder.AddAttribute(4, "EditorId", $"editor-{codeNodeId}-{codePropKey}");
                builder.AddAttribute(5, "Height", "300px");
                builder.CloseComponent();
                break;
            case PropertyType.Select:
            case PropertyType.TextArea:
            default:
                builder.OpenComponent<SfTextBox>(0); builder.AddAttribute(1, "Value", currentValue?.ToString() ?? ""); builder.AddAttribute(2, "ValueChanged", EventCallback.Factory.Create<string>(this, val => SetPropertyValue(nodeId, prop.Key, val))); builder.CloseComponent(); break;
        }
    };

    private void SetPropertyValue(string nodeId, string key, object value) { if (!NodeProperties.ContainsKey(nodeId)) NodeProperties[nodeId] = new(); NodeProperties[nodeId][key] = value; }
    private void ToggleConsole() => ConsoleExpanded = !ConsoleExpanded;
    private void ClearConsole() { ConsoleMessages.Clear(); StateHasChanged(); }
    private void AddConsoleMessage(string level, string nodeLabel, string message) { ConsoleMessages.Add(new ConsoleLogMessage { Timestamp = DateTime.Now, Level = level, NodeLabel = nodeLabel, Message = message }); if (ConsoleMessages.Count > 500) ConsoleMessages.RemoveAt(0); InvokeAsync(StateHasChanged); }
    
    // NOTE: Flow execution happens on the ENGINE, not here.
    // The App only displays flow design and monitors real-time tag values.
    // When Engine executes flows, it publishes results via MQTT which the App can display.
    
    private async Task CreateSubflowFromSelection()
    {
        if (Diagram == null) return;
        
        var selectedNodes = Nodes.Where(n => !string.IsNullOrEmpty(n.ID) && Diagram.SelectionSettings?.Nodes?.Any(sn => sn.ID == n.ID) == true).ToList();
        
        if (selectedNodes.Count < 2)
        {
            AddConsoleMessage("WARN", "System", "Select at least 2 nodes to create a subflow");
            return;
        }
        
        var subflowId = $"subflow-{Guid.NewGuid():N}";
        var subflowName = $"Subflow {ConfigService.Subflows.Count + 1}";
        
        var selectedIds = selectedNodes.Where(n => !string.IsNullOrEmpty(n.ID)).Select(n => n.ID).ToHashSet();
        var internalConnectors = Connectors.Where(c => selectedIds.Contains(c.SourceID) && selectedIds.Contains(c.TargetID)).ToList();
        
        var inputConnectors = Connectors.Where(c => !selectedIds.Contains(c.SourceID) && selectedIds.Contains(c.TargetID)).ToList();
        var outputConnectors = Connectors.Where(c => selectedIds.Contains(c.SourceID) && !selectedIds.Contains(c.TargetID)).ToList();
        
        var minX = selectedNodes.Min(n => n.OffsetX);
        var minY = selectedNodes.Min(n => n.OffsetY);
        
        var subflow = new SubflowConfig
        {
            Id = subflowId,
            Name = subflowName,
            Description = $"Subflow created from {selectedNodes.Count} nodes",
            InputCount = Math.Max(1, inputConnectors.Select(c => c.TargetPortID).Distinct().Count()),
            OutputCount = Math.Max(1, outputConnectors.Select(c => c.SourcePortID).Distinct().Count()),
            Nodes = selectedNodes.Select(n => new FlowNode
            {
                Id = n.ID,
                Type = GetNodeType(n),
                Label = GetNodeLabel(n),
                X = n.OffsetX - minX,
                Y = n.OffsetY - minY,
                Properties = NodeProperties.TryGetValue(n.ID, out var p) ? p : new()
            }).ToList(),
            Edges = internalConnectors.Select(c => new FlowEdge
            {
                Id = c.ID,
                SourceNodeId = c.SourceID,
                SourcePortId = c.SourcePortID,
                TargetNodeId = c.TargetID,
                TargetPortId = c.TargetPortID
            }).ToList()
        };
        
        await ConfigService.AddSubflowAsync(subflow);
        NodeRegistry.RegisterSubflow(subflow);
        AddConsoleMessage("INFO", "System", $"Created subflow '{subflowName}' with {selectedNodes.Count} nodes");
        
        ShowReplaceWithSubflowDialog = true;
        PendingSubflowId = subflowId;
    }
    
    private async Task ReplaceSelectionWithSubflow()
    {
        if (Diagram == null || string.IsNullOrEmpty(PendingSubflowId)) return;
        
        var selectedNodes = Nodes.Where(n => !string.IsNullOrEmpty(n.ID) && Diagram.SelectionSettings?.Nodes?.Any(sn => sn.ID == n.ID) == true).ToList();
        var selectedIds = selectedNodes.Where(n => !string.IsNullOrEmpty(n.ID)).Select(n => n.ID).ToHashSet();
        
        var centerX = selectedNodes.Average(n => n.OffsetX);
        var centerY = selectedNodes.Average(n => n.OffsetY);
        
        var incomingConnectors = Connectors.Where(c => !selectedIds.Contains(c.SourceID) && selectedIds.Contains(c.TargetID)).ToList();
        var outgoingConnectors = Connectors.Where(c => selectedIds.Contains(c.SourceID) && !selectedIds.Contains(c.TargetID)).ToList();
        
        foreach (var node in selectedNodes)
        {
            Nodes.Remove(node);
            if (!string.IsNullOrEmpty(node.ID)) NodeProperties.Remove(node.ID);
        }
        
        var connectorsToRemove = Connectors.Where(c => selectedIds.Contains(c.SourceID) || selectedIds.Contains(c.TargetID)).ToList();
        foreach (var conn in connectorsToRemove)
        {
            Connectors.Remove(conn);
        }
        
        var subflow = ConfigService.Subflows.FirstOrDefault(s => s.Id == PendingSubflowId);
        if (subflow != null)
        {
            var subflowNode = CreateFlowNode(
                $"{PendingSubflowId}-{Guid.NewGuid():N}",
                subflow.Name,
                "#8b5cf6",
                centerX, centerY,
                subflow.InputCount, subflow.OutputCount
            );
            Nodes.Add(subflowNode);
            
            foreach (var conn in incomingConnectors)
            {
                Connectors.Add(CreateFlowConnector(
                    $"conn-{Guid.NewGuid():N}",
                    conn.SourceID, conn.SourcePortID,
                    subflowNode.ID, "input-0"
                ));
            }
            
            foreach (var conn in outgoingConnectors)
            {
                Connectors.Add(CreateFlowConnector(
                    $"conn-{Guid.NewGuid():N}",
                    subflowNode.ID, "output-0",
                    conn.TargetID, conn.TargetPortID
                ));
            }
        }
        
        ShowReplaceWithSubflowDialog = false;
        PendingSubflowId = "";
        StateHasChanged();
    }
    
    private void EditSubflow(string subflowId)
    {
        var subflow = ConfigService.Subflows.FirstOrDefault(s => s.Id == subflowId);
        if (subflow == null)
        {
            AddConsoleMessage("ERROR", "System", $"Subflow '{subflowId}' not found");
            return;
        }
        
        // FIX: Re-new collections
        Nodes = new DiagramObjectCollection<Node>();
        Connectors = new DiagramObjectCollection<Connector>();
        _pendingConnectors.Clear();
        NodeProperties.Clear();
        _nodeTypes.Clear();
        ConsoleMessages.Clear();
        
        CurrentFlow = new FlowConfig
        {
            Id = subflowId,
            Name = $"Editing Subflow: {subflow.Name}",
            Description = subflow.Description,
            Enabled = false,
            ScanRateMs = 1000
        };
        
        foreach (var node in subflow.Nodes)
        {
            var mappedType = MapNodeType(node.Type);
            var plugin = NodeRegistry.Get(mappedType);
            var diagramNode = CreateFlowNode(
                node.Id,
                node.Label ?? plugin?.Name ?? node.Type,
                plugin?.Color ?? "#9ca3af",
                node.X,
                node.Y,
                plugin?.InputCount ?? 1,
                plugin?.OutputCount ?? 1
            );
            Nodes.Add(diagramNode);
            _nodeTypes[node.Id] = mappedType;
            
            if (node.Properties != null)
            {
                NodeProperties[node.Id] = new Dictionary<string, object>(node.Properties);
            }
        }
        
        foreach (var edge in subflow.Edges)
        {
            var mappedSourcePort = MapPortName(edge.SourcePortId, "output");
            var mappedTargetPort = MapPortName(edge.TargetPortId, "input");
            
            _pendingConnectors.Add(CreateFlowConnector(
                edge.Id,
                edge.SourceNodeId,
                mappedSourcePort,
                edge.TargetNodeId,
                mappedTargetPort
            ));
        }
        
        _connectorsAdded = false;
        _editingSubflowId = subflowId;
        AddConsoleMessage("INFO", "System", $"Editing subflow: {subflow.Name}");
        StateHasChanged();
    }
    
    private async Task SaveSubflow()
    {
        if (string.IsNullOrEmpty(_editingSubflowId)) return;
        
        var existingSubflow = ConfigService.Subflows.FirstOrDefault(s => s.Id == _editingSubflowId);
        if (existingSubflow == null) return;
        
        existingSubflow.Nodes = Nodes.Where(n => !string.IsNullOrEmpty(n.ID)).Select(n => new FlowNode
        {
            Id = n.ID,
            Type = _nodeTypes.TryGetValue(n.ID, out var t) ? t : GetNodeType(n),
            Label = GetNodeLabel(n),
            X = n.OffsetX,
            Y = n.OffsetY,
            Properties = NodeProperties.TryGetValue(n.ID, out var props) 
                ? props.ToDictionary(kv => kv.Key, kv => kv.Value)
                : new Dictionary<string, object>()
        }).ToList();
        
        existingSubflow.Edges = Connectors.Where(c => !string.IsNullOrEmpty(c.ID)).Select(c => new FlowEdge
        {
            Id = c.ID,
            SourceNodeId = c.SourceID,
            SourcePortId = c.SourcePortID,
            TargetNodeId = c.TargetID,
            TargetPortId = c.TargetPortID
        }).ToList();
        
        // Count only explicit subflow I/O nodes, not nodes based on connections
        existingSubflow.InputCount = Nodes.Count(n => !string.IsNullOrEmpty(n.ID) && GetNodeType(n.ID) == "subflow-input");
        existingSubflow.OutputCount = Nodes.Count(n => !string.IsNullOrEmpty(n.ID) && GetNodeType(n.ID) == "subflow-output");
        
        await ConfigService.UpdateSubflowAsync(existingSubflow);
        NodeRegistry.UnregisterSubflow(_editingSubflowId);
        NodeRegistry.RegisterSubflow(existingSubflow);
        
        AddConsoleMessage("INFO", "System", $"Saved subflow: {existingSubflow.Name}");
        _editingSubflowId = null;

        if (DataForeman.App.Components.Layout.MainLayout.Instance is { } layout)
            await layout.ShowToastAsync("Subflow saved", "e-toast-success", "Saved");
    }
    
    private void CancelSubflowEdit()
    {
        _editingSubflowId = null;
        Nodes = new DiagramObjectCollection<Node>();
        Connectors = new DiagramObjectCollection<Connector>();
        _pendingConnectors.Clear();
        NodeProperties.Clear();
        _nodeTypes.Clear();
        ConsoleMessages.Clear();
        Navigation.NavigateTo("/flows");
    }
    
    private async Task AddSubflowInput()
    {
        var plugin = NodeRegistry.Get("subflow-input");
        if (plugin == null) return;
        
        // Position on the left side of the canvas
        var existingInputs = Nodes.Count(n => GetNodeType(n.ID) == "subflow-input");
        double offsetX = 100;
        double offsetY = 150 + (existingInputs * 100);
        
        var nodeId = $"subflow-input-{Guid.NewGuid():N}";
        var node = CreateSubflowIONode(nodeId, plugin.Name, plugin.Color, offsetX, offsetY, 0, 1, true);
        
        NodeProperties[nodeId] = new Dictionary<string, object> { ["name"] = $"Input {existingInputs + 1}" };
        Nodes.Add(node);
        AddConsoleMessage("INFO", "System", $"Added subflow input node: Input {existingInputs + 1}");
        StateHasChanged();
    }
    
    private async Task AddSubflowOutput()
    {
        var plugin = NodeRegistry.Get("subflow-output");
        if (plugin == null) return;
        
        // Position on the right side of the canvas
        var existingOutputs = Nodes.Count(n => GetNodeType(n.ID) == "subflow-output");
        double offsetX = 700;
        double offsetY = 150 + (existingOutputs * 100);
        
        var nodeId = $"subflow-output-{Guid.NewGuid():N}";
        var node = CreateSubflowIONode(nodeId, plugin.Name, plugin.Color, offsetX, offsetY, 1, 0, false);
        
        NodeProperties[nodeId] = new Dictionary<string, object> { ["name"] = $"Output {existingOutputs + 1}" };
        Nodes.Add(node);
        AddConsoleMessage("INFO", "System", $"Added subflow output node: Output {existingOutputs + 1}");
        StateHasChanged();
    }
    
    private Node CreateSubflowIONode(string id, string label, string color, double x, double y, int inputCount, int outputCount, bool isInput)
    {
        var node = new Node
        {
            ID = id, OffsetX = x, OffsetY = y, Width = 140, Height = 50,
            Shape = new BasicShape { Type = NodeShapes.Basic, Shape = NodeBasicShapes.Rectangle, CornerRadius = 25 },
            Style = new ShapeStyle { Fill = "#6b7280", StrokeColor = color, StrokeWidth = 3 },
            Annotations = new DiagramObjectCollection<ShapeAnnotation>(), Ports = new DiagramObjectCollection<PointPort>(),
            Constraints = NodeConstraints.Default | NodeConstraints.AllowDrop
        };
        
        node.Annotations.Add(new ShapeAnnotation 
        { 
            Content = label, 
            Style = new TextStyle { Color = "#ffffff", FontSize = 12, Bold = true }, 
            Offset = new DiagramPoint { X = 0.5, Y = 0.5 }, 
            HorizontalAlignment = HorizontalAlignment.Center 
        });
        
        // Input node has output port on right, Output node has input port on left
        if (isInput)
        {
            node.Ports.Add(new PointPort 
            { 
                ID = "output-0", 
                Offset = new DiagramPoint { X = 1, Y = 0.5 }, 
                Visibility = PortVisibility.Visible, 
                Shape = PortShapes.Circle, 
                Width = 14, Height = 14, 
                Style = new ShapeStyle { Fill = "#f59e0b", StrokeColor = "#ffffff", StrokeWidth = 2 }, 
                Constraints = PortConstraints.Default | PortConstraints.Draw 
            });
        }
        else
        {
            node.Ports.Add(new PointPort 
            { 
                ID = "input-0", 
                Offset = new DiagramPoint { X = 0, Y = 0.5 }, 
                Visibility = PortVisibility.Visible, 
                Shape = PortShapes.Circle, 
                Width = 14, Height = 14, 
                Style = new ShapeStyle { Fill = "#3b82f6", StrokeColor = "#ffffff", StrokeWidth = 2 }, 
                Constraints = PortConstraints.Default | PortConstraints.Draw 
            });
        }
        
        return node;
    }
    
    private void ShowTemplates() => ShowTemplateDialog = true;
    
    private async Task ApplyTemplate(FlowTemplate template)
    {
        var offsetX = Nodes.Any() ? Nodes.Max(n => n.OffsetX) + 300 : 200;
        var offsetY = 150;
        
        // Map from template node IDs to new generated IDs
        var nodeIdMap = new Dictionary<string, string>();
        
        // Add nodes with new IDs
        foreach (var node in template.Nodes)
        {
            var plugin = NodeRegistry.Get(node.Type);
            var newNodeId = $"{node.Type}-{Guid.NewGuid():N}";
            nodeIdMap[node.Id] = newNodeId; // Map old ID to new ID
            
            var diagramNode = CreateFlowNode(
                newNodeId,
                node.Label ?? plugin?.Name ?? node.Type,
                plugin?.Color ?? "#9ca3af",
                node.X + offsetX,
                node.Y + offsetY,
                plugin?.InputCount ?? 1,
                plugin?.OutputCount ?? 1
            );
            Nodes.Add(diagramNode);
            _nodeTypes[newNodeId] = node.Type;
            
            if (node.Properties != null)
            {
                NodeProperties[diagramNode.ID] = new Dictionary<string, object>(node.Properties);
            }
        }
        
        // Add edges with mapped node IDs
        if (template.Edges != null && template.Edges.Any())
        {
            var connectorsToAdd = new List<Connector>();
            foreach (var edge in template.Edges)
            {
                // Map the source and target node IDs to the new IDs
                if (nodeIdMap.TryGetValue(edge.SourceNodeId, out var newSourceId) &&
                    nodeIdMap.TryGetValue(edge.TargetNodeId, out var newTargetId))
                {
                    var connector = CreateFlowConnector(
                        $"edge-{Guid.NewGuid():N}",
                        newSourceId,
                        edge.SourcePortId,
                        newTargetId,
                        edge.TargetPortId
                    );
                    connectorsToAdd.Add(connector);
                }
            }
            
            // Add connectors to the diagram
            if (connectorsToAdd.Any() && Diagram != null)
            {
                try
                {
                    await Task.Delay(100); // Wait for nodes to be rendered
                    await Diagram.AddDiagramElementsAsync(new DiagramObjectCollection<NodeBase>(connectorsToAdd.Cast<NodeBase>()));
                    AddConsoleMessage("INFO", "System", $"Added {connectorsToAdd.Count} connectors from template");
                }
                catch (Exception ex)
                {
                    AddConsoleMessage("ERROR", "System", $"Failed to add connectors: {ex.Message}");
                }
            }
        }
        
        AddConsoleMessage("INFO", "System", $"Applied template: {template.Name} ({template.Nodes.Count} nodes)");
        ShowTemplateDialog = false;
        StateHasChanged();
    }
    
    private async Task SaveAsTemplate()
    {
        if (!Nodes.Any()) return;
        
        var template = new FlowTemplate
        {
            Id = Guid.NewGuid().ToString(),
            Name = $"{CurrentFlow.Name} Template",
            Description = CurrentFlow.Description ?? "Custom template",
            Category = "Custom",
            Nodes = Nodes.Select(n => new FlowNode
            {
                Id = n.ID,
                Type = GetNodeType(n),
                Label = GetNodeLabel(n),
                X = n.OffsetX,
                Y = n.OffsetY,
                Properties = NodeProperties.TryGetValue(n.ID, out var p) ? p : new()
            }).ToList(),
            Edges = Connectors.Select(c => new FlowEdge
            {
                Id = c.ID,
                SourceNodeId = c.SourceID,
                SourcePortId = c.SourcePortID,
                TargetNodeId = c.TargetID,
                TargetPortId = c.TargetPortID
            }).ToList()
        };
        
        await ConfigService.AddFlowTemplateAsync(template);
        AddConsoleMessage("INFO", "System", $"Saved as template: {template.Name}");
    }
    
    // --- Live Value Annotations ---

    private void ToggleLiveValues()
    {
        _showLiveValues = !_showLiveValues;
        if (!_showLiveValues)
        {
            ClearAllLiveAnnotations();
        }
    }

    private static string FormatLiveValue(Dictionary<string, object> data)
    {
        if (data.Count == 1)
        {
            var val = data.Values.First();
            return FormatSingleValue(val);
        }
        // Multiple values: show first 2 as key=val pairs
        var parts = data.Take(2).Select(kv => $"{kv.Key}={FormatSingleValue(kv.Value)}");
        var result = string.Join(" ", parts);
        if (data.Count > 2) result += " â€¦";
        return result;
    }

    private static string FormatSingleValue(object val)
    {
        if (val is double d) return d.ToString(d == Math.Floor(d) ? "F0" : "G7");
        // Dictionary<string, object> values arrive as JsonElement after JSON round-trip
        if (val is System.Text.Json.JsonElement je)
        {
            return je.ValueKind switch
            {
                System.Text.Json.JsonValueKind.Number when je.TryGetDouble(out var jd)
                    => jd.ToString(jd == Math.Floor(jd) ? "F0" : "G7"),
                System.Text.Json.JsonValueKind.Number when je.TryGetInt64(out var ji)
                    => ji.ToString(),
                System.Text.Json.JsonValueKind.Number
                    => je.GetRawText(),
                System.Text.Json.JsonValueKind.True => "True",
                System.Text.Json.JsonValueKind.False => "False",
                System.Text.Json.JsonValueKind.String => TruncateString(je.GetString() ?? ""),
                _ => TruncateString(je.ToString())
            };
        }
        return TruncateString(val?.ToString() ?? "");
    }

    private static string TruncateString(string s)
        => s.Length > 20 ? s[..17] + "â€¦" : s;

    /// <summary>
    /// Updates annotations on every in/out port of a node with live values.
    /// Annotations[0] = node name, [1] = category.
    /// Annotations[2..2+inputCount-1] = input port labels.
    /// Annotations[2+inputCount..2+inputCount+outputCount-1] = output port labels.
    /// </summary>
    private void UpdatePortAnnotations(Node node, string inputText, string outputText, bool isError)
    {
        if (node.Ports == null || node.Annotations == null) return;

        var inputPorts = node.Ports.Where(p => p.ID.StartsWith("input-")).ToList();
        var outputPorts = node.Ports.Where(p => p.ID.StartsWith("output-")).ToList();
        var totalAnnotationsNeeded = 2 + inputPorts.Count + outputPorts.Count;

        // Annotations were pre-created in CreateFlowNode; bail if they're missing
        if (node.Annotations.Count < totalAnnotationsNeeded) return;

        var valueColor = isError ? "#ef5350" : "#00e5ff";

        // Update input port annotations (indices 2..2+inputCount-1)
        for (int i = 0; i < inputPorts.Count; i++)
        {
            var ann = node.Annotations[2 + i];
            ann.Content = inputText;
            if (ann.Style != null)
            {
                ann.Style.Color = valueColor;
            }
        }

        // Update output port annotations (indices 2+inputCount..end)
        for (int i = 0; i < outputPorts.Count; i++)
        {
            var ann = node.Annotations[2 + inputPorts.Count + i];
            ann.Content = outputText;
            if (ann.Style != null)
            {
                ann.Style.Color = valueColor;
            }
        }
    }

    private void ClearAllLiveAnnotations()
    {
        _livePortValues.Clear();
        foreach (var node in Nodes)
        {
            if (node.Annotations == null) continue;
            // Clear content of port value annotations (indices 2+) without removing them
            for (int i = 2; i < node.Annotations.Count; i++)
            {
                node.Annotations[i].Content = "";
            }
        }
        StateHasChanged();
    }

    public void Dispose()
    {
        // Set disposed flag first to stop any running execution
        _disposed = true;
        
        // Cancel any pending async operations
        try
        {
            _cts?.Cancel();
            _cts?.Dispose();
        }
        catch { /* Ignore disposal errors */ }
        
        _simulationTimer?.Dispose();
        RealtimeData.OnTagValueChanged -= HandleTagValueChanged;
        RealtimeData.OnFlowExecutionReceived -= HandleFlowExecutionReceived;
        RealtimeData.OnFlowDeployStatusChanged -= HandleDeployStatusChanged;
        RealtimeData.OnFlowRunSummaryReceived -= HandleFlowRunSummary;
    }

    public class FlowDisplay
    {
        public string Id { get; set; } = "";
        public string Name { get; set; } = "";
        public string Description { get; set; } = "";
        public int NodeCount { get; set; }
        public bool Enabled { get; set; }
    }
    
    public class ConsoleLogMessage
    {
        public DateTime Timestamp { get; set; }
        public string Level { get; set; } = "INFO";
        public string NodeLabel { get; set; } = "";
        public string Message { get; set; } = "";
    }

    public class FlowTagPathOption
    {
        public string Path { get; set; } = string.Empty;
        public string Label { get; set; } = string.Empty;
    }
}

