@page "/flows"
@page "/flows/{FlowId}"
@rendermode InteractiveServer
@inject ConfigService ConfigService
@inject NodePluginRegistry NodeRegistry
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime
@implements IDisposable

<PageTitle>Flows - DataForeman</PageTitle>

<div class="page-container">
    @if (string.IsNullOrEmpty(FlowId))
    {
        <!-- Flow List View -->
        <div class="page-toolbar">
            <h2><i class="fa-solid fa-diagram-project"></i> Flows</h2>
            <div class="toolbar-actions">
                <SfButton CssClass="e-primary" IconCss="fa-solid fa-plus" @onclick="CreateNewFlow">New Flow</SfButton>
            </div>
        </div>
        
        @if (!ConfigService.Flows.Any())
        {
            <div class="empty-state">
                <i class="fa-solid fa-diagram-project"></i>
                <span>No flows configured</span>
                <SfButton CssClass="e-primary e-small" @onclick="CreateNewFlow">Create your first flow</SfButton>
            </div>
        }
        else
        {
            <SfGrid DataSource="@FlowsList" AllowPaging="true">
                <GridPageSettings PageSize="10"></GridPageSettings>
                <GridColumns>
                    <GridColumn Field="@nameof(FlowDisplay.Name)" HeaderText="Name" Width="200"></GridColumn>
                    <GridColumn Field="@nameof(FlowDisplay.Description)" HeaderText="Description" Width="300"></GridColumn>
                    <GridColumn Field="@nameof(FlowDisplay.NodeCount)" HeaderText="Nodes" Width="80"></GridColumn>
                    <GridColumn HeaderText="Status" Width="100">
                        <Template>
                            @{
                                var item = (context as FlowDisplay);
                                <span class="status-indicator @(item?.Enabled == true ? "enabled" : "disabled")">
                                    <i class="fa-solid fa-circle"></i> @(item?.Enabled == true ? "Enabled" : "Disabled")
                                </span>
                            }
                        </Template>
                    </GridColumn>
                    <GridColumn HeaderText="Actions" Width="120">
                        <Template>
                            @{
                                var item = (context as FlowDisplay);
                                <div class="action-buttons">
                                    <SfButton CssClass="e-flat e-small" IconCss="fa-solid fa-pen" @onclick="() => EditFlow(item!.Id)"></SfButton>
                                    <SfButton CssClass="e-flat e-small e-danger" IconCss="fa-solid fa-trash" @onclick="() => ConfirmDeleteFlow(item!.Id)"></SfButton>
                                </div>
                            }
                        </Template>
                    </GridColumn>
                </GridColumns>
            </SfGrid>
        }
    }
    else
    {
        <!-- Flow Editor View -->
        <div class="flow-editor">
            <div class="editor-toolbar">
                <SfButton CssClass="e-flat" IconCss="fa-solid fa-arrow-left" @onclick="GoBack"></SfButton>
                <SfTextBox @bind-Value="CurrentFlow.Name" Placeholder="Flow Name" CssClass="flow-name-input"></SfTextBox>
                <div class="toolbar-spacer"></div>
                <SfButton CssClass="e-flat" IconCss="fa-solid fa-layer-group" Content="Templates" @onclick="ShowTemplates" title="Apply Template"></SfButton>
                <SfButton CssClass="e-flat" IconCss="fa-solid fa-file-export" @onclick="SaveAsTemplate" title="Save as Template"></SfButton>
                <SfButton CssClass="e-flat" IconCss="fa-solid fa-object-group" @onclick="CreateSubflowFromSelection" title="Create Subflow from Selection"></SfButton>
                <span class="toolbar-separator"></span>
                <SfButton CssClass="@(CurrentFlow.Enabled ? "e-warning" : "e-success")" 
                          IconCss="@(CurrentFlow.Enabled ? "fa-solid fa-pause" : "fa-solid fa-play")"
                          Content="@(CurrentFlow.Enabled ? "Disable" : "Enable")"
                          @onclick="ToggleEnabled"></SfButton>
                <SfButton CssClass="e-primary" IconCss="fa-solid fa-floppy-disk" @onclick="SaveFlow">Save</SfButton>
            </div>
            
            <div class="editor-content">
                <!-- Node Palette (Custom HTML5 - not hardcoded, from NodeRegistry) -->
                <div class="node-palette">
                    <div class="palette-header">NODE PALETTE</div>
                    @foreach (var category in NodeRegistry.Categories)
                    {
                        var plugins = NodeRegistry.GetByCategory(category);
                        if (!plugins.Any()) continue;
                        
                        <div class="palette-category">
                            <div class="category-header" @onclick="() => ToggleCategory(category)">
                                <span class="toggle-icon">@(ExpandedCategories.Contains(category) ? "▼" : "▶")</span>
                                @category.ToUpperInvariant()
                            </div>
                            @if (ExpandedCategories.Contains(category))
                            {
                                <div class="category-nodes">
                                    @foreach (var plugin in plugins)
                                    {
                                        <div class="palette-node" 
                                             draggable="true"
                                             style="border-left-color: @plugin.Color"
                                             @ondragstart="() => OnPaletteDragStart(plugin)"
                                             @onclick="() => AddNodeFromPalette(plugin)">
                                            <span class="node-icon"><i class="@plugin.Icon" style="color: @plugin.Color"></i></span>
                                            <span class="node-label">@plugin.ShortLabel</span>
                                        </div>
                                    }
                                </div>
                            }
                        </div>
                    }
                </div>
                
                <!-- Diagram Canvas -->
                <div class="diagram-container" 
                     id="diagram-space"
                     @ondragover="OnDiagramDragOver"
                     @ondragover:preventDefault="true"
                     @ondrop="OnDiagramDrop"
                     @ondrop:preventDefault="true">
                    <SfDiagramComponent @ref="Diagram" 
                                        ID="diagram"
                                        Width="100%" 
                                        Height="100%"
                                        Nodes="@Nodes"
                                        Connectors="@Connectors"
                                        NodeCreating="@OnNodeCreating"
                                        ConnectorCreating="@OnConnectorCreating"
                                        SelectionChanged="@OnSelectionChanged"
                                        ConnectionChanged="@OnConnectionChanged">
                        <SnapSettings>
                            <HorizontalGridLines LineColor="#3a4049" LineDashArray="2,4"></HorizontalGridLines>
                            <VerticalGridLines LineColor="#3a4049" LineDashArray="2,4"></VerticalGridLines>
                        </SnapSettings>
                        <ScrollSettings ScrollLimit="ScrollLimitMode.Diagram"></ScrollSettings>
                    </SfDiagramComponent>
                </div>
                
                <!-- Properties Panel -->
                <div class="properties-panel">
                    <h3>Properties</h3>
                    @if (SelectedNode != null)
                    {
                        var plugin = NodeRegistry.Get(GetNodeBaseType(SelectedNode));
                        <div class="property-header">
                            <span class="node-type-badge" style="border-color: @(plugin?.Color ?? "#9ca3af")">
                                <i class="@(plugin?.Icon ?? "fa-solid fa-question")" style="color: @(plugin?.Color ?? "#9ca3af")"></i>
                                @(plugin?.Name ?? GetNodeType(SelectedNode))
                            </span>
                        </div>
                        
                        @if (plugin != null)
                        {
                            <p class="plugin-description">@plugin.Description</p>
                        }
                        
                        <div class="property-group">
                            <label>Label</label>
                            <SfTextBox Value="@SelectedNodeLabel" ValueChanged="@OnLabelChanged"></SfTextBox>
                        </div>
                        
                        @if (plugin != null)
                        {
                            @foreach (var prop in plugin.Properties.Where(p => !p.Advanced))
                            {
                                <div class="property-group">
                                    <label>@prop.Label @(prop.Required ? "*" : "")</label>
                                    @RenderPropertyInput(prop)
                                    @if (!string.IsNullOrEmpty(prop.HelpText))
                                    {
                                        <span class="property-hint">@prop.HelpText</span>
                                    }
                                </div>
                            }
                        }
                        
                        <div class="property-actions">
                            <SfButton CssClass="e-danger e-small" IconCss="fa-solid fa-trash" @onclick="DeleteSelectedNode">Delete Node</SfButton>
                        </div>
                    }
                    else
                    {
                        <p class="no-selection">Select a node to view properties</p>
                    }
                    
                    <div class="flow-settings">
                        <h4>Flow Settings</h4>
                        <div class="property-group">
                            <label>Description</label>
                            <SfTextBox @bind-Value="CurrentFlow.Description" Multiline="true"></SfTextBox>
                        </div>
                        <div class="property-group">
                            <label>Scan Rate (ms)</label>
                            <SfNumericTextBox TValue="int" @bind-Value="CurrentFlow.ScanRateMs" Min="10" Max="60000"></SfNumericTextBox>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Collapsible Output Console -->
            <div class="output-console @(ConsoleExpanded ? "expanded" : "collapsed")">
                <div class="console-header" @onclick="ToggleConsole">
                    <span class="console-toggle"><i class="fa-solid @(ConsoleExpanded ? "fa-chevron-down" : "fa-chevron-up")"></i></span>
                    <span class="console-title"><i class="fa-solid fa-terminal"></i> Output Console</span>
                    <span class="console-badge">@ConsoleMessages.Count</span>
                    <div class="console-actions">
                        <button class="console-btn" @onclick:stopPropagation="true" @onclick="ClearConsole" title="Clear"><i class="fa-solid fa-trash"></i></button>
                        <button class="console-btn" @onclick:stopPropagation="true" @onclick="SimulateExecution" title="Test Run"><i class="fa-solid fa-play"></i></button>
                    </div>
                </div>
                @if (ConsoleExpanded)
                {
                    <div class="console-body" @ref="ConsoleBody">
                        @if (!ConsoleMessages.Any())
                        {
                            <div class="console-empty">No output yet. Click <i class="fa-solid fa-play"></i> to test the flow.</div>
                        }
                        else
                        {
                            @foreach (var msg in ConsoleMessages)
                            {
                                <div class="console-line @msg.Level.ToLower()">
                                    <span class="console-time">@msg.Timestamp.ToString("HH:mm:ss.fff")</span>
                                    <span class="console-level">[@msg.Level]</span>
                                    <span class="console-node">@msg.NodeLabel</span>
                                    <span class="console-text">@msg.Message</span>
                                </div>
                            }
                        }
                    </div>
                }
            </div>
        </div>
    }
</div>

<!-- Delete Confirmation Dialog -->
<SfDialog @bind-Visible="ShowDeleteDialog" Width="350px" IsModal="true" ShowCloseIcon="true">
    <DialogTemplates>
        <Header>Confirm Delete</Header>
        <Content>
            <p>Delete this flow?</p>
            <p class="text-muted">This action cannot be undone.</p>
        </Content>
        <FooterTemplate>
            <SfButton @onclick="() => ShowDeleteDialog = false">Cancel</SfButton>
            <SfButton CssClass="e-danger" @onclick="ExecuteDeleteFlow">Delete</SfButton>
        </FooterTemplate>
    </DialogTemplates>
</SfDialog>

<!-- Template Selection Dialog -->
<SfDialog @bind-Visible="ShowTemplateDialog" Width="500px" IsModal="true" ShowCloseIcon="true">
    <DialogTemplates>
        <Header><i class="fa-solid fa-layer-group"></i> Flow Templates</Header>
        <Content>
            @if (!AvailableTemplates.Any())
            {
                <p class="text-muted">No templates available. Save a flow as template first.</p>
            }
            else
            {
                <div class="template-list">
                    @foreach (var template in AvailableTemplates)
                    {
                        <div class="template-card" @onclick="() => ApplyTemplate(template)">
                            <div class="template-name"><i class="fa-solid fa-file-code"></i> @template.Name</div>
                            <div class="template-description">@template.Description</div>
                            <div class="template-meta">
                                <span class="template-category">@template.Category</span>
                                <span class="template-nodes">@template.Nodes.Count nodes</span>
                            </div>
                        </div>
                    }
                </div>
            }
        </Content>
        <FooterTemplate>
            <SfButton @onclick="() => ShowTemplateDialog = false">Close</SfButton>
        </FooterTemplate>
    </DialogTemplates>
</SfDialog>

<!-- Replace with Subflow Dialog -->
<SfDialog @bind-Visible="ShowReplaceWithSubflowDialog" Width="400px" IsModal="true" ShowCloseIcon="true">
    <DialogTemplates>
        <Header><i class="fa-solid fa-object-group"></i> Subflow Created</Header>
        <Content>
            <p>Subflow has been created and added to the palette.</p>
            <p>Would you like to replace the selected nodes with the new subflow node?</p>
        </Content>
        <FooterTemplate>
            <SfButton @onclick="() => { ShowReplaceWithSubflowDialog = false; PendingSubflowId = string.Empty; }">Keep Nodes</SfButton>
            <SfButton CssClass="e-primary" @onclick="ReplaceSelectionWithSubflow">Replace with Subflow</SfButton>
        </FooterTemplate>
    </DialogTemplates>
</SfDialog>

@code {
    [Parameter] public string? FlowId { get; set; }
    
    private SfDiagramComponent? Diagram;
    private DiagramObjectCollection<Node> Nodes = new();
    private DiagramObjectCollection<Connector> Connectors = new();
    private Node? SelectedNode;
    private string SelectedNodeLabel = "";
    
    // Palette state
    private HashSet<string> ExpandedCategories = new() { "Triggers", "Tags" };
    private NodePluginDefinition? _draggingPlugin;
    
    private FlowConfig CurrentFlow = new();
    private bool ShowDeleteDialog;
    private string DeleteFlowId = "";
    
    // Node property values storage
    private Dictionary<string, Dictionary<string, object>> NodeProperties = new();
    
    // Output Console
    private bool ConsoleExpanded = true;
    private List<ConsoleLogMessage> ConsoleMessages = new();
    private ElementReference ConsoleBody;
    private System.Timers.Timer? _simulationTimer;

    private List<FlowDisplay> FlowsList => ConfigService.Flows.Select(f => new FlowDisplay
    {
        Id = f.Id,
        Name = f.Name,
        Description = f.Description ?? "",
        NodeCount = f.Nodes.Count,
        Enabled = f.Enabled
    }).ToList();

    protected override async Task OnInitializedAsync()
    {
        await ConfigService.LoadAllAsync();
    }

    protected override void OnParametersSet()
    {
        if (!string.IsNullOrEmpty(FlowId))
        {
            var flow = ConfigService.Flows.FirstOrDefault(f => f.Id == FlowId);
            if (flow != null)
            {
                CurrentFlow = flow;
                LoadFlowDefinition(flow);
            }
            else if (FlowId == "new")
            {
                CurrentFlow = new FlowConfig { Name = "New Flow" };
                Nodes = new DiagramObjectCollection<Node>();
                Connectors = new DiagramObjectCollection<Connector>();
            }
        }
    }

    private void LoadFlowDefinition(FlowConfig flow)
    {
        Nodes = new DiagramObjectCollection<Node>();
        Connectors = new DiagramObjectCollection<Connector>();
        NodeProperties.Clear();
        
        foreach (var node in flow.Nodes)
        {
            var plugin = NodeRegistry.Get(node.Type);
            var diagramNode = CreateFlowNode(
                node.Id,
                node.Label ?? plugin?.Name ?? node.Type,
                plugin?.Color ?? "#9ca3af",
                node.X,
                node.Y,
                plugin?.InputCount ?? 1,
                plugin?.OutputCount ?? 1
            );
            Nodes.Add(diagramNode);
            
            // Store node properties
            if (node.Properties != null)
            {
                NodeProperties[node.Id] = new Dictionary<string, object>(node.Properties);
            }
        }
        
        foreach (var edge in flow.Edges)
        {
            Connectors.Add(CreateFlowConnector(
                edge.Id,
                edge.SourceNodeId,
                edge.SourcePortId,
                edge.TargetNodeId,
                edge.TargetPortId
            ));
        }
    }

    private void CreateNewFlow() => Navigation.NavigateTo("/flows/new");
    private void EditFlow(string id) => Navigation.NavigateTo($"/flows/{id}");
    private void GoBack() => Navigation.NavigateTo("/flows");
    
    private void ToggleEnabled() => CurrentFlow.Enabled = !CurrentFlow.Enabled;

    private async Task SaveFlow()
    {
        // Convert diagram nodes to flow nodes
        CurrentFlow.Nodes = Nodes.Select(n => new FlowNode
        {
            Id = n.ID,
            Type = GetNodeBaseType(n),
            Label = GetNodeLabel(n),
            X = n.OffsetX,
            Y = n.OffsetY,
            Properties = NodeProperties.TryGetValue(n.ID, out var props) ? props : new()
        }).ToList();
        
        // Convert connectors to edges
        CurrentFlow.Edges = Connectors.Select(c => new FlowEdge
        {
            Id = c.ID,
            SourceNodeId = c.SourceID,
            SourcePortId = c.SourcePortID,
            TargetNodeId = c.TargetID,
            TargetPortId = c.TargetPortID
        }).ToList();
        
        CurrentFlow.UpdatedAt = DateTime.UtcNow;
        
        if (FlowId == "new")
        {
            await ConfigService.AddFlowAsync(CurrentFlow);
        }
        else
        {
            await ConfigService.UpdateFlowAsync(CurrentFlow);
        }
        
        Navigation.NavigateTo("/flows");
    }

    private void ConfirmDeleteFlow(string id)
    {
        DeleteFlowId = id;
        ShowDeleteDialog = true;
    }

    private async Task ExecuteDeleteFlow()
    {
        await ConfigService.DeleteFlowAsync(DeleteFlowId);
        ShowDeleteDialog = false;
    }

    // Palette interactions
    private void ToggleCategory(string category)
    {
        if (ExpandedCategories.Contains(category))
            ExpandedCategories.Remove(category);
        else
            ExpandedCategories.Add(category);
    }

    private void OnPaletteDragStart(NodePluginDefinition plugin)
    {
        _draggingPlugin = plugin;
    }

    private void OnDiagramDragOver(Microsoft.AspNetCore.Components.Web.DragEventArgs e)
    {
        e.DataTransfer.DropEffect = "copy";
    }

    private async Task OnDiagramDrop(Microsoft.AspNetCore.Components.Web.DragEventArgs e)
    {
        if (_draggingPlugin == null || Diagram == null) return;
        
        try
        {
            var diagramRect = await JSRuntime.InvokeAsync<Dictionary<string, double>>(
                "eval", 
                "(() => { const rect = document.getElementById('diagram-space').getBoundingClientRect(); return { left: rect.left, top: rect.top }; })()");
            
            double diagramX = e.ClientX - diagramRect["left"];
            double diagramY = e.ClientY - diagramRect["top"];
            
            await AddNodeFromPalette(_draggingPlugin, diagramX, diagramY);
        }
        finally
        {
            _draggingPlugin = null;
        }
    }

    private async Task AddNodeFromPalette(NodePluginDefinition plugin, double? x = null, double? y = null)
    {
        if (Diagram == null) return;
        
        double offsetX = x ?? (400 + (Nodes.Count % 4) * 220);
        double offsetY = y ?? (150 + (Nodes.Count / 4) * 120);
        
        var nodeId = $"{plugin.Id}-{Guid.NewGuid():N}";
        var node = CreateFlowNode(
            nodeId,
            plugin.Name,
            plugin.Color,
            offsetX, offsetY,
            plugin.InputCount, plugin.OutputCount
        );
        
        // Initialize default properties (cast to object)
        NodeProperties[nodeId] = plugin.Properties
            .Where(p => !string.IsNullOrEmpty(p.DefaultValue))
            .ToDictionary(p => p.Key, p => (object)p.DefaultValue);
        
        Nodes.Add(node);
        StateHasChanged();
    }

    private Node CreateFlowNode(string id, string label, string color, double x, double y, int inputCount, int outputCount)
    {
        var baseType = GetBaseTypeFromId(id);
        var plugin = NodeRegistry.Get(baseType);
        
        var node = new Node
        {
            ID = id,
            OffsetX = x,
            OffsetY = y,
            Width = 180,
            Height = 70,
            Shape = new BasicShape { Type = NodeShapes.Basic, Shape = NodeBasicShapes.Rectangle, CornerRadius = 8 },
            Style = new ShapeStyle { Fill = "#2a2a2a", StrokeColor = color, StrokeWidth = 2 },
            Annotations = new DiagramObjectCollection<ShapeAnnotation>(),
            Ports = new DiagramObjectCollection<PointPort>(),
            Constraints = NodeConstraints.Default | NodeConstraints.AllowDrop
        };
        
        // Main label
        node.Annotations.Add(new ShapeAnnotation
        {
            Content = label,
            Style = new TextStyle { Color = "#ffffff", FontSize = 13, Bold = true },
            Offset = new DiagramPoint { X = 0.5, Y = 0.35 },
            HorizontalAlignment = HorizontalAlignment.Center
        });
        
        // Category subtitle
        var category = plugin?.Category ?? "Node";
        node.Annotations.Add(new ShapeAnnotation
        {
            Content = category,
            Style = new TextStyle { Color = "#9d9d9d", FontSize = 10, Italic = true },
            Offset = new DiagramPoint { X = 0.5, Y = 0.7 },
            HorizontalAlignment = HorizontalAlignment.Center
        });
        
        // Input ports
        for (int i = 0; i < inputCount; i++)
        {
            var yOffset = inputCount == 1 ? 0.5 : (i + 1.0) / (inputCount + 1);
            node.Ports.Add(new PointPort
            {
                ID = $"input-{i}",
                Offset = new DiagramPoint { X = 0, Y = yOffset },
                Visibility = PortVisibility.Visible,
                Shape = PortShapes.Circle,
                Width = 12, Height = 12,
                Style = new ShapeStyle { Fill = "#3b82f6", StrokeColor = "#ffffff", StrokeWidth = 2 },
                Constraints = PortConstraints.Default | PortConstraints.Draw
            });
        }
        
        // Output ports
        for (int i = 0; i < outputCount; i++)
        {
            var yOffset = outputCount == 1 ? 0.5 : (i + 1.0) / (outputCount + 1);
            node.Ports.Add(new PointPort
            {
                ID = $"output-{i}",
                Offset = new DiagramPoint { X = 1, Y = yOffset },
                Visibility = PortVisibility.Visible,
                Shape = PortShapes.Circle,
                Width = 12, Height = 12,
                Style = new ShapeStyle { Fill = "#f59e0b", StrokeColor = "#ffffff", StrokeWidth = 2 },
                Constraints = PortConstraints.Default | PortConstraints.Draw
            });
        }
        
        return node;
    }

    private Connector CreateFlowConnector(string id, string sourceId, string? sourcePort, string targetId, string? targetPort)
    {
        return new Connector
        {
            ID = id,
            SourceID = sourceId,
            SourcePortID = sourcePort ?? "output-0",
            TargetID = targetId,
            TargetPortID = targetPort ?? "input-0",
            Type = ConnectorSegmentType.Bezier,
            Style = new ShapeStyle { StrokeColor = "#6b7280", StrokeWidth = 2 },
            TargetDecorator = new DecoratorSettings
            {
                Shape = DecoratorShape.Arrow,
                Style = new ShapeStyle { Fill = "#6b7280", StrokeColor = "#6b7280" }
            }
        };
    }

    private void OnNodeCreating(IDiagramObject obj)
    {
        if (obj is Node node)
        {
            node.Style.Fill = "#2a2a2a";
        }
    }

    private void OnConnectorCreating(IDiagramObject obj)
    {
        if (obj is Connector connector)
        {
            connector.Type = ConnectorSegmentType.Bezier;
            connector.Style.StrokeColor = "#6b7280";
            connector.Style.StrokeWidth = 2;
            
            // Set arrow decorator
            connector.TargetDecorator = new DecoratorSettings
            {
                Shape = DecoratorShape.Arrow,
                Style = new ShapeStyle { Fill = "#6b7280", StrokeColor = "#6b7280" }
            };
        }
    }

    private void OnConnectionChanged(Syncfusion.Blazor.Diagram.ConnectionChangedEventArgs args)
    {
        // Log connection changes to console
        if (args.Connector != null && !string.IsNullOrEmpty(args.Connector.SourceID) && !string.IsNullOrEmpty(args.Connector.TargetID))
        {
            var sourceNode = Nodes.FirstOrDefault(n => n.ID == args.Connector.SourceID);
            var targetNode = Nodes.FirstOrDefault(n => n.ID == args.Connector.TargetID);
            
            var sourceLabel = sourceNode != null ? GetNodeLabel(sourceNode) : args.Connector.SourceID;
            var targetLabel = targetNode != null ? GetNodeLabel(targetNode) : args.Connector.TargetID;
            var sourcePort = args.Connector.SourcePortID ?? "output-0";
            var targetPort = args.Connector.TargetPortID ?? "input-0";
            
            AddConsoleMessage("INFO", "System", $"Connected: {sourceLabel}[{sourcePort}] → {targetLabel}[{targetPort}]");
        }
    }

    private void OnSelectionChanged(Syncfusion.Blazor.Diagram.SelectionChangedEventArgs args)
    {
        if (args.NewValue?.Count > 0 && args.NewValue[0] is Node node)
        {
            SelectedNode = node;
            SelectedNodeLabel = GetNodeLabel(node);
        }
        else
        {
            SelectedNode = null;
            SelectedNodeLabel = "";
        }
    }

    private async Task OnLabelChanged(string newLabel)
    {
        if (SelectedNode == null || Diagram == null) return;
        
        SelectedNodeLabel = newLabel;
        if (SelectedNode.Annotations.Count > 0)
        {
            SelectedNode.Annotations[0].Content = newLabel;
            StateHasChanged();
        }
    }

    private async Task DeleteSelectedNode()
    {
        if (SelectedNode == null || Diagram == null) return;
        
        var nodeId = SelectedNode.ID;
        Nodes.Remove(SelectedNode);
        NodeProperties.Remove(nodeId);
        
        // Remove connected connectors
        var connectedConnectors = Connectors.Where(c => c.SourceID == nodeId || c.TargetID == nodeId).ToList();
        foreach (var conn in connectedConnectors)
        {
            Connectors.Remove(conn);
        }
        
        SelectedNode = null;
        StateHasChanged();
    }

    private string GetNodeLabel(Node node) => node.Annotations?.FirstOrDefault()?.Content ?? node.ID;
    private string GetNodeType(Node node) => GetBaseTypeFromId(node.ID);
    private string GetNodeBaseType(Node node) => GetBaseTypeFromId(node.ID);
    
    private string GetBaseTypeFromId(string id)
    {
        // Handle IDs like "trigger-manual-abc123" or "math-add-instance-xyz"
        if (id.Contains("-instance-"))
            return id.Split("-instance-")[0];
        
        // Try to match against known plugin IDs
        var parts = id.Split('-');
        for (int i = parts.Length; i > 0; i--)
        {
            var candidate = string.Join("-", parts.Take(i));
            if (NodeRegistry.Get(candidate) != null)
                return candidate;
        }
        
        // Fallback: remove last segment if it looks like a GUID
        if (parts.Length > 1 && parts[^1].Length >= 8)
            return string.Join("-", parts.Take(parts.Length - 1));
        
        return id;
    }

    private RenderFragment RenderPropertyInput(NodePropertyDefinition prop) => builder =>
    {
        var nodeId = SelectedNode?.ID;
        if (nodeId == null) return;
        
        if (!NodeProperties.ContainsKey(nodeId))
            NodeProperties[nodeId] = new();
        
        var currentValue = NodeProperties[nodeId].TryGetValue(prop.Key, out var v) ? v?.ToString() : prop.DefaultValue;
        
        switch (prop.Type)
        {
            case PropertyType.Text:
                builder.OpenComponent<SfTextBox>(0);
                builder.AddAttribute(1, "Value", currentValue ?? "");
                builder.AddAttribute(2, "ValueChanged", EventCallback.Factory.Create<string>(this, val => SetPropertyValue(nodeId, prop.Key, val)));
                builder.AddAttribute(3, "Placeholder", prop.Placeholder);
                builder.CloseComponent();
                break;
                
            case PropertyType.Integer:
                builder.OpenComponent<SfNumericTextBox<int>>(0);
                builder.AddAttribute(1, "Value", int.TryParse(currentValue, out var intVal) ? intVal : 0);
                builder.AddAttribute(2, "ValueChanged", EventCallback.Factory.Create<int>(this, val => SetPropertyValue(nodeId, prop.Key, val.ToString())));
                builder.AddAttribute(3, "Min", (int)(prop.Min ?? int.MinValue));
                builder.AddAttribute(4, "Max", (int)(prop.Max ?? int.MaxValue));
                builder.CloseComponent();
                break;
                
            case PropertyType.Decimal:
                builder.OpenComponent<SfNumericTextBox<double>>(0);
                builder.AddAttribute(1, "Value", double.TryParse(currentValue, out var dblVal) ? dblVal : 0);
                builder.AddAttribute(2, "ValueChanged", EventCallback.Factory.Create<double>(this, val => SetPropertyValue(nodeId, prop.Key, val.ToString())));
                builder.CloseComponent();
                break;
                
            case PropertyType.Boolean:
                builder.OpenComponent<SfCheckBox<bool>>(0);
                builder.AddAttribute(1, "Checked", currentValue?.ToLower() == "true");
                builder.AddAttribute(2, "CheckedChanged", EventCallback.Factory.Create<bool>(this, val => SetPropertyValue(nodeId, prop.Key, val.ToString().ToLower())));
                builder.CloseComponent();
                break;
                
            case PropertyType.Select:
                // For select, just render a simple text input for now (complex dropdowns need different handling)
                builder.OpenComponent<SfTextBox>(0);
                builder.AddAttribute(1, "Value", currentValue?.ToString() ?? "");
                builder.AddAttribute(2, "ValueChanged", EventCallback.Factory.Create<string>(this, val => SetPropertyValue(nodeId, prop.Key, val)));
                builder.AddAttribute(3, "Placeholder", string.Join(", ", prop.Options.Select(o => o.Label)));
                builder.CloseComponent();
                break;
                
            case PropertyType.TextArea:
                builder.OpenComponent<SfTextBox>(0);
                builder.AddAttribute(1, "Value", currentValue?.ToString() ?? "");
                builder.AddAttribute(2, "ValueChanged", EventCallback.Factory.Create<string>(this, val => SetPropertyValue(nodeId, prop.Key, val)));
                builder.AddAttribute(3, "Multiline", true);
                builder.CloseComponent();
                break;
                
            default:
                builder.OpenComponent<SfTextBox>(0);
                builder.AddAttribute(1, "Value", currentValue?.ToString() ?? "");
                builder.AddAttribute(2, "ValueChanged", EventCallback.Factory.Create<string>(this, val => SetPropertyValue(nodeId, prop.Key, val)));
                builder.CloseComponent();
                break;
        }
    };

    private void SetPropertyValue(string nodeId, string key, object value)
    {
        if (!NodeProperties.ContainsKey(nodeId))
            NodeProperties[nodeId] = new();
        NodeProperties[nodeId][key] = value;
    }

    // Console methods
    private void ToggleConsole() => ConsoleExpanded = !ConsoleExpanded;
    
    private void ClearConsole()
    {
        ConsoleMessages.Clear();
        StateHasChanged();
    }
    
    private void AddConsoleMessage(string level, string nodeLabel, string message)
    {
        ConsoleMessages.Add(new ConsoleLogMessage
        {
            Timestamp = DateTime.Now,
            Level = level,
            NodeLabel = nodeLabel,
            Message = message
        });
        
        // Keep only last 500 messages
        if (ConsoleMessages.Count > 500)
            ConsoleMessages.RemoveAt(0);
            
        InvokeAsync(StateHasChanged);
    }
    
    private async Task SimulateExecution()
    {
        if (!Nodes.Any())
        {
            AddConsoleMessage("WARN", "System", "No nodes to execute");
            return;
        }
        
        AddConsoleMessage("INFO", "System", $"Starting flow execution: {CurrentFlow.Name}");
        
        // Find trigger nodes (nodes with no inputs connected)
        var triggerNodes = Nodes.Where(n => 
        {
            var plugin = NodeRegistry.Get(GetNodeBaseType(n));
            return plugin?.Category == "Triggers";
        }).ToList();
        
        if (!triggerNodes.Any())
        {
            // If no trigger nodes, start from nodes with no incoming connections
            var nodesWithIncoming = Connectors.Select(c => c.TargetID).ToHashSet();
            triggerNodes = Nodes.Where(n => !nodesWithIncoming.Contains(n.ID)).ToList();
        }
        
        foreach (var triggerNode in triggerNodes)
        {
            await SimulateNodeExecution(triggerNode, new Dictionary<string, object> { ["value"] = GenerateSimulatedValue(triggerNode) });
        }
        
        AddConsoleMessage("INFO", "System", "Flow execution completed");
    }
    
    private async Task SimulateNodeExecution(Node node, Dictionary<string, object> inputData)
    {
        var label = GetNodeLabel(node);
        var baseType = GetNodeBaseType(node);
        var plugin = NodeRegistry.Get(baseType);
        
        // Simulate processing delay
        await Task.Delay(50);
        
        // Generate output based on node type
        object outputValue = inputData.TryGetValue("value", out var val) ? val : 0.0;
        
        switch (plugin?.Category)
        {
            case "Triggers":
                outputValue = GenerateSimulatedValue(node);
                AddConsoleMessage("INFO", label, $"Triggered with value: {outputValue}");
                break;
                
            case "Tags":
                if (baseType.Contains("input"))
                {
                    outputValue = Math.Round(new Random().NextDouble() * 100, 2);
                    AddConsoleMessage("INFO", label, $"Read tag value: {outputValue}");
                }
                else
                {
                    AddConsoleMessage("INFO", label, $"Writing value: {outputValue}");
                }
                break;
                
            case "Math":
                var factor = NodeProperties.TryGetValue(node.ID, out var props) && props.TryGetValue("factor", out var f) ? Convert.ToDouble(f) : 1.0;
                if (baseType.Contains("scale")) outputValue = Convert.ToDouble(outputValue) * factor;
                else if (baseType.Contains("add")) outputValue = Convert.ToDouble(outputValue) + factor;
                else if (baseType.Contains("multiply")) outputValue = Convert.ToDouble(outputValue) * factor;
                AddConsoleMessage("DEBUG", label, $"Input: {val} → Output: {outputValue}");
                break;
                
            case "Logic":
                var threshold = NodeProperties.TryGetValue(node.ID, out var lprops) && lprops.TryGetValue("threshold", out var t) ? Convert.ToDouble(t) : 50.0;
                var result = Convert.ToDouble(outputValue) > threshold;
                AddConsoleMessage("DEBUG", label, $"Comparing {outputValue} > {threshold} = {result}");
                outputValue = result;
                break;
                
            case "Output":
                if (baseType.Contains("debug"))
                {
                    AddConsoleMessage("DEBUG", label, $"► {outputValue}");
                }
                else if (baseType.Contains("notification"))
                {
                    AddConsoleMessage("WARN", label, $"Notification: {outputValue}");
                }
                break;
                
            case "Data Processing":
                AddConsoleMessage("DEBUG", label, $"Processed: {outputValue}");
                break;
                
            default:
                AddConsoleMessage("DEBUG", label, $"Executed with value: {outputValue}");
                break;
        }
        
        // Find connected nodes and execute them
        var outgoingConnectors = Connectors.Where(c => c.SourceID == node.ID).ToList();
        foreach (var connector in outgoingConnectors)
        {
            var targetNode = Nodes.FirstOrDefault(n => n.ID == connector.TargetID);
            if (targetNode != null)
            {
                await SimulateNodeExecution(targetNode, new Dictionary<string, object> { ["value"] = outputValue });
            }
        }
    }
    
    private object GenerateSimulatedValue(Node node)
    {
        var baseType = GetNodeBaseType(node);
        if (baseType.Contains("timer") || baseType.Contains("schedule"))
            return DateTime.Now.ToString("HH:mm:ss");
        if (baseType.Contains("manual"))
            return "Manual Trigger";
        return Math.Round(new Random().NextDouble() * 100, 2);
    }
    
    // Subflow methods
    private async Task CreateSubflowFromSelection()
    {
        if (Diagram == null) return;
        
        var selectedNodes = Nodes.Where(n => Diagram.SelectionSettings?.Nodes?.Any(sn => sn.ID == n.ID) == true).ToList();
        
        if (selectedNodes.Count < 2)
        {
            AddConsoleMessage("WARN", "System", "Select at least 2 nodes to create a subflow");
            return;
        }
        
        // Create subflow definition
        var subflowId = $"subflow-{Guid.NewGuid():N}";
        var subflowName = $"Subflow {ConfigService.Subflows.Count + 1}";
        
        // Find internal connectors (both source and target are in selection)
        var selectedIds = selectedNodes.Select(n => n.ID).ToHashSet();
        var internalConnectors = Connectors.Where(c => selectedIds.Contains(c.SourceID) && selectedIds.Contains(c.TargetID)).ToList();
        
        // Find input/output nodes (connected to nodes outside selection)
        var inputConnectors = Connectors.Where(c => !selectedIds.Contains(c.SourceID) && selectedIds.Contains(c.TargetID)).ToList();
        var outputConnectors = Connectors.Where(c => selectedIds.Contains(c.SourceID) && !selectedIds.Contains(c.TargetID)).ToList();
        
        // Calculate bounding box for relative positions
        var minX = selectedNodes.Min(n => n.OffsetX);
        var minY = selectedNodes.Min(n => n.OffsetY);
        
        var subflow = new SubflowConfig
        {
            Id = subflowId,
            Name = subflowName,
            Description = $"Subflow created from {selectedNodes.Count} nodes",
            InputCount = Math.Max(1, inputConnectors.Select(c => c.TargetPortID).Distinct().Count()),
            OutputCount = Math.Max(1, outputConnectors.Select(c => c.SourcePortID).Distinct().Count()),
            Nodes = selectedNodes.Select(n => new FlowNode
            {
                Id = n.ID,
                Type = GetNodeBaseType(n),
                Label = GetNodeLabel(n),
                X = n.OffsetX - minX,
                Y = n.OffsetY - minY,
                Properties = NodeProperties.TryGetValue(n.ID, out var p) ? p : new()
            }).ToList(),
            Edges = internalConnectors.Select(c => new FlowEdge
            {
                Id = c.ID,
                SourceNodeId = c.SourceID,
                SourcePortId = c.SourcePortID,
                TargetNodeId = c.TargetID,
                TargetPortId = c.TargetPortID
            }).ToList()
        };
        
        await ConfigService.AddSubflowAsync(subflow);
        
        // Register as a node plugin
        NodeRegistry.RegisterSubflow(subflow);
        
        AddConsoleMessage("INFO", "System", $"Created subflow '{subflowName}' with {selectedNodes.Count} nodes");
        
        // Optionally remove selected nodes and replace with subflow node
        ShowReplaceWithSubflowDialog = true;
        PendingSubflowId = subflowId;
    }
    
    private bool ShowReplaceWithSubflowDialog;
    private string PendingSubflowId = "";
    
    private async Task ReplaceSelectionWithSubflow()
    {
        if (Diagram == null || string.IsNullOrEmpty(PendingSubflowId)) return;
        
        var selectedNodes = Nodes.Where(n => Diagram.SelectionSettings?.Nodes?.Any(sn => sn.ID == n.ID) == true).ToList();
        var selectedIds = selectedNodes.Select(n => n.ID).ToHashSet();
        
        // Calculate center position
        var centerX = selectedNodes.Average(n => n.OffsetX);
        var centerY = selectedNodes.Average(n => n.OffsetY);
        
        // Find external connections
        var incomingConnectors = Connectors.Where(c => !selectedIds.Contains(c.SourceID) && selectedIds.Contains(c.TargetID)).ToList();
        var outgoingConnectors = Connectors.Where(c => selectedIds.Contains(c.SourceID) && !selectedIds.Contains(c.TargetID)).ToList();
        
        // Remove selected nodes and their internal connectors
        foreach (var node in selectedNodes)
        {
            Nodes.Remove(node);
            NodeProperties.Remove(node.ID);
        }
        
        var connectorsToRemove = Connectors.Where(c => selectedIds.Contains(c.SourceID) || selectedIds.Contains(c.TargetID)).ToList();
        foreach (var conn in connectorsToRemove)
        {
            Connectors.Remove(conn);
        }
        
        // Add subflow node
        var subflow = ConfigService.Subflows.FirstOrDefault(s => s.Id == PendingSubflowId);
        if (subflow != null)
        {
            var subflowNode = CreateFlowNode(
                $"{PendingSubflowId}-{Guid.NewGuid():N}",
                subflow.Name,
                "#8b5cf6", // Purple for subflows
                centerX, centerY,
                subflow.InputCount, subflow.OutputCount
            );
            Nodes.Add(subflowNode);
            
            // Reconnect external connections
            foreach (var conn in incomingConnectors)
            {
                Connectors.Add(CreateFlowConnector(
                    $"conn-{Guid.NewGuid():N}",
                    conn.SourceID, conn.SourcePortID,
                    subflowNode.ID, "input-0"
                ));
            }
            
            foreach (var conn in outgoingConnectors)
            {
                Connectors.Add(CreateFlowConnector(
                    $"conn-{Guid.NewGuid():N}",
                    subflowNode.ID, "output-0",
                    conn.TargetID, conn.TargetPortID
                ));
            }
        }
        
        ShowReplaceWithSubflowDialog = false;
        PendingSubflowId = "";
        StateHasChanged();
    }
    
    // Template methods
    private bool ShowTemplateDialog;
    private List<FlowTemplate> AvailableTemplates => ConfigService.FlowTemplates.ToList();
    
    private void ShowTemplates() => ShowTemplateDialog = true;
    
    private async Task ApplyTemplate(FlowTemplate template)
    {
        // Add template nodes to current flow
        var offsetX = Nodes.Any() ? Nodes.Max(n => n.OffsetX) + 300 : 200;
        var offsetY = 150;
        
        foreach (var node in template.Nodes)
        {
            var plugin = NodeRegistry.Get(node.Type);
            var diagramNode = CreateFlowNode(
                $"{node.Type}-{Guid.NewGuid():N}",
                node.Label ?? plugin?.Name ?? node.Type,
                plugin?.Color ?? "#9ca3af",
                node.X + offsetX,
                node.Y + offsetY,
                plugin?.InputCount ?? 1,
                plugin?.OutputCount ?? 1
            );
            Nodes.Add(diagramNode);
            
            if (node.Properties != null)
            {
                NodeProperties[diagramNode.ID] = new Dictionary<string, object>(node.Properties);
            }
        }
        
        // Note: Template edges reference original node IDs, so we'd need to map them
        // For simplicity, user can reconnect after applying template
        
        AddConsoleMessage("INFO", "System", $"Applied template: {template.Name}");
        ShowTemplateDialog = false;
        StateHasChanged();
    }
    
    private async Task SaveAsTemplate()
    {
        if (!Nodes.Any())
        {
            AddConsoleMessage("WARN", "System", "No nodes to save as template");
            return;
        }
        
        var template = new FlowTemplate
        {
            Id = Guid.NewGuid().ToString(),
            Name = $"{CurrentFlow.Name} Template",
            Description = CurrentFlow.Description ?? "Custom template",
            Category = "Custom",
            Nodes = Nodes.Select(n => new FlowNode
            {
                Id = n.ID,
                Type = GetNodeBaseType(n),
                Label = GetNodeLabel(n),
                X = n.OffsetX,
                Y = n.OffsetY,
                Properties = NodeProperties.TryGetValue(n.ID, out var p) ? p : new()
            }).ToList(),
            Edges = Connectors.Select(c => new FlowEdge
            {
                Id = c.ID,
                SourceNodeId = c.SourceID,
                SourcePortId = c.SourcePortID,
                TargetNodeId = c.TargetID,
                TargetPortId = c.TargetPortID
            }).ToList()
        };
        
        await ConfigService.AddFlowTemplateAsync(template);
        AddConsoleMessage("INFO", "System", $"Saved as template: {template.Name}");
    }
    
    public void Dispose()
    {
        _simulationTimer?.Dispose();
    }

    public class FlowDisplay
    {
        public string Id { get; set; } = "";
        public string Name { get; set; } = "";
        public string Description { get; set; } = "";
        public int NodeCount { get; set; }
        public bool Enabled { get; set; }
    }
    
    public class ConsoleLogMessage
    {
        public DateTime Timestamp { get; set; }
        public string Level { get; set; } = "INFO";
        public string NodeLabel { get; set; } = "";
        public string Message { get; set; } = "";
    }
}
