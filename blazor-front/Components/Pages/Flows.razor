@page "/flows"
@page "/flows/{FlowId:guid}"
@rendermode InteractiveServer
@using DataForeman.BlazorUI.Services
@using Microsoft.JSInterop
@inject DataService DataService
@inject NodePluginRegistry NodeRegistry
@inject IJSRuntime JSRuntime

<PageTitle>Flow Studio - DataForeman</PageTitle>

<div class="flows-page">
    @if (FlowId == Guid.Empty)
    {
        <div class="page-header">
            <h1>Flow Studio</h1>
            <div class="page-actions">
                <SfButton CssClass="e-primary" IconCss="e-icons e-plus" Content="New Flow" OnClick="@CreateNewFlow"></SfButton>
            </div>
        </div>
        
        @if (IsLoading)
        {
            <div class="loading-indicator">
                <span>Loading flows...</span>
            </div>
        }
        else
        {
            <SfGrid DataSource="@FlowsList" AllowPaging="true" AllowSorting="true" AllowFiltering="true">
                <GridColumns>
                    <GridColumn Field="@nameof(FlowListItem.Name)" HeaderText="Name" Width="200"></GridColumn>
                    <GridColumn Field="@nameof(FlowListItem.Description)" HeaderText="Description" Width="300"></GridColumn>
                    <GridColumn Field="@nameof(FlowListItem.Status)" HeaderText="Status" Width="100">
                        <Template>
                            @{
                                var flow = context as FlowListItem;
                                if (flow != null)
                                {
                                    <span class="status-badge @(flow.Deployed ? "deployed" : "stopped")">
                                        @(flow.Deployed ? "Deployed" : "Stopped")
                                    </span>
                                }
                            }
                        </Template>
                    </GridColumn>
                    <GridColumn Field="@nameof(FlowListItem.UpdatedAt)" HeaderText="Last Updated" Width="150" Format="g"></GridColumn>
                    <GridColumn HeaderText="Actions" Width="150">
                        <Template>
                            @{
                                var flow = context as FlowListItem;
                                if (flow != null)
                                {
                                    <div class="action-buttons">
                                        <SfButton CssClass="e-flat e-small" IconCss="e-icons e-edit" OnClick="@(() => EditFlow(flow.Id))"></SfButton>
                                        <SfButton CssClass="e-flat e-small" IconCss="e-icons e-delete" OnClick="@(async () => await DeleteFlow(flow.Id))"></SfButton>
                                    </div>
                                }
                            }
                        </Template>
                    </GridColumn>
                </GridColumns>
            </SfGrid>
        }
    }
    else
    {
        <div class="flow-editor">
            <div class="editor-toolbar">
                <SfButton CssClass="e-flat" IconCss="e-icons e-arrow-left" Content="Back" OnClick="@GoBack"></SfButton>
                <SfTextBox @bind-Value="CurrentFlow.Name" Placeholder="Flow Name" CssClass="flow-name-input"></SfTextBox>
                <div class="toolbar-spacer"></div>
                @if (_showSaveMessage)
                {
                    <span class="save-message">@_saveMessage</span>
                }
                <SfButton CssClass="@(CurrentFlow.Deployed ? "e-danger" : "e-success")" IconCss="@(CurrentFlow.Deployed ? "e-icons e-stop" : "e-icons e-play")" Content="@(CurrentFlow.Deployed ? "Stop" : "Deploy")" OnClick="@ToggleDeploy"></SfButton>
                <SfButton CssClass="e-primary" IconCss="e-icons e-save" Content="Save" OnClick="@SaveFlow"></SfButton>
            </div>
            
            <div class="editor-container">
                @* Custom HTML5 Palette - more reliable than Syncfusion SymbolPalette *@
                <div class="custom-palette">
                    <div class="palette-header">NODE PALETTE</div>
                    @foreach (var category in NodeRegistry.Categories)
                    {
                        var plugins = NodeRegistry.GetByCategory(category);
                        if (plugins.Count == 0) continue;
                        
                        <div class="palette-category">
                            <div class="category-header" @onclick="() => ToggleCategory(category)">
                                <span class="toggle-icon">@(ExpandedCategories.Contains(category) ? "▼" : "▶")</span>
                                @category.ToUpperInvariant()
                            </div>
                            @if (ExpandedCategories.Contains(category))
                            {
                                <div class="category-nodes">
                                    @foreach (var plugin in plugins)
                                    {
                                        <div class="palette-node" 
                                             draggable="true"
                                             style="border-left-color: @plugin.Color"
                                             @ondragstart="() => OnPaletteDragStart(plugin)"
                                             @onclick="() => AddNodeFromPalette(plugin)">
                                            <span class="node-icon" style="color: @plugin.Color">@plugin.Icon</span>
                                            <span class="node-label">@plugin.ShortLabel</span>
                                        </div>
                                    }
                                </div>
                            }
                        </div>
                    }
                </div>
                
                @* Syncfusion Diagram *@
                <div class="diagram-container" 
                     id="diagram-space"
                     @ondragover="OnDiagramDragOver"
                     @ondragover:preventDefault="true"
                     @ondrop="OnDiagramDrop"
                     @ondrop:preventDefault="true">
                    <SfDiagramComponent @ref="Diagram" 
                                        ID="diagram"
                                        Width="100%" 
                                        Height="100%"
                                        Nodes="@Nodes"
                                        Connectors="@Connectors"
                                        NodeCreating="@OnNodeCreating"
                                        ConnectorCreating="@OnConnectorCreating"
                                        SelectionChanged="@OnSelectionChanged">
                        <SnapSettings>
                            <HorizontalGridLines LineColor="#3a4049" LineDashArray="2,4"></HorizontalGridLines>
                            <VerticalGridLines LineColor="#3a4049" LineDashArray="2,4"></VerticalGridLines>
                        </SnapSettings>
                        <ScrollSettings ScrollLimit="ScrollLimitMode.Diagram"></ScrollSettings>
                    </SfDiagramComponent>
                </div>
                
                <div class="properties-panel">
                    <h3>Properties</h3>
                    @if (SelectedNode != null)
                    {
                        var plugin = NodeRegistry.Get(GetNodeBaseType(SelectedNode));
                        <div class="property-header">
                            <span class="node-type-badge" style="border-color: @(plugin?.Color ?? "#9ca3af")">
                                <span class="badge-icon">@(plugin?.Icon ?? "[?]")</span>
                                @(plugin?.Name ?? GetNodeType(SelectedNode))
                            </span>
                        </div>
                        
                        @if (plugin != null)
                        {
                            <p class="plugin-description">@plugin.Description</p>
                        }
                        
                        <div class="property-group">
                            <label>Label</label>
                            <SfTextBox Value="@SelectedNodeLabel" ValueChanged="@OnLabelChanged" Placeholder="Enter label"></SfTextBox>
                        </div>
                        
                        @* Dynamic properties from plugin metadata *@
                        @if (plugin != null)
                        {
                            @foreach (var group in plugin.Properties.Where(p => !p.Advanced).GroupBy(p => p.Group).OrderBy(g => g.Key))
                            {
                                <div class="property-section">
                                    <h4>@group.Key</h4>
                                    @foreach (var prop in group.OrderBy(p => p.Order))
                                    {
                                        <div class="property-group">
                                            <label>@prop.Label @(prop.Required ? "*" : "")</label>
                                            @RenderPropertyInput(prop)
                                            @if (!string.IsNullOrEmpty(prop.HelpText))
                                            {
                                                <span class="property-hint">@prop.HelpText</span>
                                            }
                                        </div>
                                    }
                                </div>
                            }
                            
                            @* Advanced properties toggle *@
                            @if (plugin.Properties.Any(p => p.Advanced))
                            {
                                <div class="advanced-toggle" @onclick="@(() => _showAdvanced = !_showAdvanced)">
                                    <span class="toggle-icon">@(_showAdvanced ? "▼" : "▶")</span>
                                    Advanced Options
                                </div>
                                
                                @if (_showAdvanced)
                                {
                                    @foreach (var group in plugin.Properties.Where(p => p.Advanced).GroupBy(p => p.Group).OrderBy(g => g.Key))
                                    {
                                        <div class="property-section advanced">
                                            <h4>@group.Key</h4>
                                            @foreach (var prop in group.OrderBy(p => p.Order))
                                            {
                                                <div class="property-group">
                                                    <label>@prop.Label @(prop.Required ? "*" : "")</label>
                                                    @RenderPropertyInput(prop)
                                                    @if (!string.IsNullOrEmpty(prop.HelpText))
                                                    {
                                                        <span class="property-hint">@prop.HelpText</span>
                                                    }
                                                </div>
                                            }
                                        </div>
                                    }
                                }
                            }
                        }
                        
                        <div class="property-actions">
                            <SfButton CssClass="e-danger e-small" IconCss="e-icons e-delete" Content="Delete Node" OnClick="@DeleteSelectedNode"></SfButton>
                        </div>
                        
                        @* Plugin info footer *@
                        @if (plugin != null)
                        {
                            <div class="plugin-info">
                                <span class="plugin-version">v@(plugin.Version)</span>
                                @if (plugin.IsBuiltIn)
                                {
                                    <span class="plugin-builtin">Built-in</span>
                                }
                            </div>
                        }
                    }
                    else
                    {
                        <p class="no-selection">Select a node to view properties</p>
                    }
                </div>
            </div>
        </div>
    }
</div>

<style>
    .flows-page {
        height: 100%;
    }
    
    .page-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 24px;
    }
    
    .page-header h1 {
        margin: 0;
    }
    
    .loading-indicator {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 40px;
        color: #9d9d9d;
        font-style: italic;
    }
    
    .status-badge {
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: 500;
    }
    
    .status-badge.deployed {
        background: #4caf50;
        color: white;
    }
    
    .status-badge.stopped {
        background: #757575;
        color: white;
    }
    
    .action-buttons {
        display: flex;
        gap: 4px;
    }
    
    .flow-editor {
        display: flex;
        flex-direction: column;
        height: calc(100vh - 120px);
    }
    
    .editor-toolbar {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px;
        background: #252526;
        border-bottom: 1px solid #3c3c3c;
    }
    
    .flow-name-input {
        width: 250px;
    }
    
    .toolbar-spacer {
        flex: 1;
    }
    
    .editor-container {
        display: flex;
        flex: 1;
        overflow: hidden;
    }
    
    /* Custom HTML5 Palette - reliable drag-drop */
    .custom-palette {
        width: 180px;
        min-width: 180px;
        background: #1a1d21;
        border-right: 1px solid #3a4049;
        order: -1;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
    }
    
    .palette-header {
        padding: 10px 12px;
        font-size: 10px;
        font-weight: 700;
        color: #9ea3ad;
        letter-spacing: 1px;
        background: #23272e;
        border-bottom: 1px solid #3a4049;
        position: sticky;
        top: 0;
        z-index: 10;
    }
    
    .palette-category {
        border-bottom: 1px solid #2d323b;
    }
    
    .category-header {
        padding: 8px 12px;
        font-size: 10px;
        font-weight: 600;
        color: #9ea3ad;
        letter-spacing: 0.5px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 6px;
        background: #1e2228;
        user-select: none;
    }
    
    .category-header:hover {
        background: #23272e;
        color: #f59e0b;
    }
    
    .toggle-icon {
        font-size: 8px;
    }
    
    .category-nodes {
        padding: 6px;
        display: flex;
        flex-direction: column;
        gap: 4px;
    }
    
    .palette-node {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 10px;
        background: #23272e;
        border: 1px solid #3a4049;
        border-left: 3px solid #9ca3af;
        border-radius: 4px;
        cursor: grab;
        transition: all 0.15s ease;
    }
    
    .palette-node:hover {
        background: #2d323b;
        border-color: #4a5568;
        transform: translateX(2px);
    }
    
    .palette-node:active {
        cursor: grabbing;
        transform: scale(0.98);
    }
    
    .palette-node .node-icon {
        font-family: Consolas, monospace;
        font-size: 9px;
        font-weight: bold;
        padding: 2px 4px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 3px;
    }
    
    .palette-node .node-label {
        font-size: 11px;
        color: #e4e6ea;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .diagram-container {
        flex: 1;
        background: #2d323b;
        min-height: 500px;
    }
    
    .properties-panel {
        width: 280px;
        background: #252526;
        border-left: 1px solid #3c3c3c;
        padding: 12px;
        overflow-y: auto;
    }
    
    .properties-panel h3 {
        margin: 0 0 16px 0;
        font-size: 14px;
        border-bottom: 1px solid #3c3c3c;
        padding-bottom: 8px;
    }
    
    .property-header {
        margin-bottom: 16px;
    }
    
    .node-type-badge {
        display: inline-block;
        padding: 4px 10px;
        background: #3c3c3c;
        border-radius: 4px;
        font-size: 11px;
        font-weight: 600;
        color: #4caf50;
        letter-spacing: 0.5px;
    }
    
    .property-group {
        margin-bottom: 16px;
    }
    
    .property-group label {
        display: block;
        font-size: 12px;
        color: #9d9d9d;
        margin-bottom: 4px;
    }
    
    .property-value {
        font-size: 13px;
        color: #cccccc;
        padding: 4px 8px;
        background: #3c3c3c;
        border-radius: 4px;
    }
    
    .property-hint {
        font-size: 11px;
        color: #757575;
        font-style: italic;
        margin: 0 0 12px 0;
        line-height: 1.4;
    }
    
    .no-selection {
        color: #9d9d9d;
        font-style: italic;
        font-size: 13px;
    }
    
    .property-section {
        margin-top: 20px;
        padding-top: 16px;
        border-top: 1px solid #3c3c3c;
    }
    
    .property-section h4 {
        margin: 0 0 12px 0;
        font-size: 13px;
        color: #ffffff;
        font-weight: 600;
    }
    
    .property-actions {
        margin-top: 24px;
        padding-top: 16px;
        border-top: 1px solid #3c3c3c;
    }
    
    /* Plugin description */
    .plugin-description {
        font-size: 11px;
        color: #9ea3ad;
        margin: 0 0 16px 0;
        line-height: 1.4;
        padding: 8px;
        background: #1e2228;
        border-radius: 4px;
        border-left: 3px solid #f59e0b;
    }
    
    /* Advanced options toggle */
    .advanced-toggle {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 0;
        margin-top: 16px;
        cursor: pointer;
        color: #9ea3ad;
        font-size: 11px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        border-top: 1px solid #3c3c3c;
    }
    
    .advanced-toggle:hover {
        color: #f59e0b;
    }
    
    .toggle-icon {
        font-size: 10px;
    }
    
    /* Advanced section styling */
    .property-section.advanced {
        background: #1e2228;
        margin: 8px -12px 0;
        padding: 12px;
        border-top: none;
    }
    
    .property-section.advanced h4 {
        color: #9ea3ad;
        font-size: 11px;
    }
    
    /* Plugin info footer */
    .plugin-info {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 20px;
        padding-top: 12px;
        border-top: 1px solid #3c3c3c;
        font-size: 10px;
        color: #6b7280;
    }
    
    .plugin-version {
        font-family: Consolas, monospace;
    }
    
    .plugin-builtin {
        background: #374151;
        padding: 2px 6px;
        border-radius: 3px;
    }
    
    /* Enhanced node type badge for plugin */
    .node-type-badge {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 12px;
        background: #1e2228;
        border: 1px solid currentColor;
        border-radius: 4px;
        font-size: 12px;
        font-weight: 600;
        color: #e4e6ea;
    }
    
    .node-type-badge .badge-icon {
        font-family: Consolas, monospace;
        font-size: 10px;
        padding: 2px 4px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 3px;
    }
    
    /* Hint styling below inputs */
    .property-group .property-hint {
        display: block;
        margin-top: 4px;
        font-size: 10px;
        color: #6b7280;
        font-style: normal;
    }
    
    /* Code editor styling for script nodes */
    .code-editor {
        font-family: 'Consolas', 'Monaco', 'Courier New', monospace !important;
        font-size: 12px !important;
        line-height: 1.4 !important;
        background: #1e1e1e !important;
        color: #d4d4d4 !important;
        border: 1px solid #3a4049 !important;
        border-radius: 4px !important;
    }
    
    .code-editor textarea {
        font-family: 'Consolas', 'Monaco', 'Courier New', monospace !important;
        min-height: 150px !important;
        tab-size: 2 !important;
    }

    /* Syncfusion Symbol Palette styling - Industrial Dark Theme */
    .e-symbol-palette {
        background: #1a1d21 !important;
        border: none !important;
        border-right: 1px solid #3a4049 !important;
    }
    
    .e-symbol-palette .e-palette-header {
        background: #23272e !important;
        color: #9ea3ad !important;
        font-size: 10px !important;
        font-weight: 700 !important;
        letter-spacing: 0.5px !important;
        border-bottom: 1px solid #3a4049 !important;
        padding: 10px 12px !important;
        text-transform: uppercase !important;
    }
    
    .e-symbol-palette .e-palette-content {
        background: #1a1d21 !important;
        padding: 8px 4px !important;
    }
    
    .e-symbol-palette .e-symbol-draggable {
        background: transparent !important;
        border: none !important;
        margin: 2px !important;
        padding: 2px !important;
        cursor: grab !important;
        transition: transform 0.15s ease !important;
    }
    
    .e-symbol-palette .e-symbol-draggable:hover {
        background: rgba(245, 158, 11, 0.1) !important;
        border-radius: 4px !important;
        transform: scale(1.02) !important;
    }
    
    .e-symbol-palette .e-symbol-draggable:active {
        cursor: grabbing !important;
    }
    
    /* Syncfusion Diagram styling - Dark Canvas */
    .e-diagram {
        background: #2d323b !important;
    }
    
    .e-diagram-canvas {
        background: #2d323b !important;
    }
    
    .save-message {
        color: #4caf50;
        font-size: 13px;
        padding: 0 12px;
        animation: fadeIn 0.3s ease-in;
    }
    
    @@keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }
</style>

@code {
    [Parameter] public Guid FlowId { get; set; }
    [Inject] NavigationManager Navigation { get; set; } = default!;
    
    private SfDiagramComponent? Diagram;
    
    private DiagramObjectCollection<Node> Nodes = new();
    private DiagramObjectCollection<Connector> Connectors = new();
    private Node? SelectedNode;
    private string SelectedNodeLabel = "";
    
    // Custom palette state
    private HashSet<string> ExpandedCategories = new() { "Triggers", "Tags" };
    private NodePluginDefinition? _draggingPlugin;
    
    private FlowListItem CurrentFlow = new() { Name = "New Flow" };
    private bool IsLoading = true;
    
    // Flows list - loaded from API or sample data
    private List<FlowListItem> FlowsList = new();
    
    // Toggle category expansion
    private void ToggleCategory(string category)
    {
        if (ExpandedCategories.Contains(category))
            ExpandedCategories.Remove(category);
        else
            ExpandedCategories.Add(category);
    }
    
    // Custom drag-drop handlers
    private void OnPaletteDragStart(NodePluginDefinition plugin)
    {
        _draggingPlugin = plugin;
    }
    
    private void OnDiagramDragOver(Microsoft.AspNetCore.Components.Web.DragEventArgs e)
    {
        // Allow drop
        e.DataTransfer.DropEffect = "copy";
    }
    
    private async Task OnDiagramDrop(Microsoft.AspNetCore.Components.Web.DragEventArgs e)
    {
        if (_draggingPlugin == null || Diagram == null) return;
        
        try
        {
            // Get the diagram container element's position
            var diagramRect = await JSRuntime.InvokeAsync<Dictionary<string, double>>(
                "eval", 
                "(() => { const rect = document.getElementById('diagram-space').getBoundingClientRect(); return { left: rect.left, top: rect.top }; })()");
            
            // Transform client coordinates to diagram coordinates
            double diagramX = e.ClientX - diagramRect["left"];
            double diagramY = e.ClientY - diagramRect["top"];
            
            // Add node at the drop position
            await AddNodeFromPalette(_draggingPlugin, diagramX, diagramY);
        }
        finally
        {
            _draggingPlugin = null;
        }
    }
    
    // Add node from palette (called by both click and drop)
    private async Task AddNodeFromPalette(NodePluginDefinition plugin, double? x = null, double? y = null)
    {
        if (Diagram == null) return;
        
        // Use provided coordinates or calculate default position for new node (offset from last node or center)
        double offsetX = x ?? (400 + (Nodes.Count % 4) * 220);
        double offsetY = y ?? (150 + (Nodes.Count / 4) * 120);
        
        var node = CreateFlowNode(
            $"{plugin.Id}-instance-{Guid.NewGuid():N}",
            plugin.Name,
            plugin.Color,
            offsetX, offsetY,
            plugin.InputCount, plugin.OutputCount
        );
        
        Nodes.Add(node);
        StateHasChanged();
    }
    
    protected override async Task OnInitializedAsync()
    {
        await LoadFlows();
        
        // Load flow definition after flows are loaded
        if (FlowId != Guid.Empty)
        {
            var flow = FlowsList.FirstOrDefault(f => f.Id == FlowId);
            if (flow != null)
            {
                CurrentFlow = flow;
                LoadFlowDefinition(flow);
            }
        }
    }
    
    protected override void OnParametersSet()
    {
        // Only handle parameter changes after initial load
        if (FlowsList.Count > 0 && FlowId != Guid.Empty)
        {
            var flow = FlowsList.FirstOrDefault(f => f.Id == FlowId);
            if (flow != null && CurrentFlow.Id != flow.Id)
            {
                CurrentFlow = flow;
                LoadFlowDefinition(flow);
            }
        }
    }
    
    private bool _connectorsAdded = false;
    private bool _isLoadingFlowDefinition = false; // Flag to prevent ID regeneration during flow loading
    private DiagramObjectCollection<Connector> _pendingConnectors = new();
    private Dictionary<string, string> _nodeTypes = new(); // Maps node IDs to their type (e.g., "node_1" -> "tag-input")
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Add connectors after the diagram and nodes are fully rendered
        // Reset condition to check _connectorsAdded instead of _firstRender to allow multiple loads
        if (!_connectorsAdded && FlowId != Guid.Empty && Diagram != null && _pendingConnectors.Count > 0)
        {
            _connectorsAdded = true;
            
            // Wait for nodes to be fully rendered in the diagram
            await Task.Delay(500);
            
            // NOW clear the loading flag - after nodes have been processed by OnNodeCreating
            // This ensures node IDs are preserved during the async rendering process
            _isLoadingFlowDefinition = false;
            
            // Add connectors programmatically after nodes are rendered using Diagram API
            try
            {
                // Convert pending connectors to list for AddDiagramElements
                var connectorsToAdd = _pendingConnectors.ToList();
                
                // Use AddDiagramElementsAsync to properly add connectors to the rendered diagram
                await Diagram.AddDiagramElementsAsync(new DiagramObjectCollection<NodeBase>(connectorsToAdd.Cast<NodeBase>()));
                
                // Clear pending connectors after they're added
                _pendingConnectors.Clear();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to add connectors: {ex.Message}");
            }
        }
    }
    
    private async Task LoadFlows()
    {
        IsLoading = true;
        
        try
        {
            // Load from DataService
            var (flows, _) = await DataService.GetFlowsAsync();
            if (flows != null && flows.Count > 0)
            {
                FlowsList = flows.Select(f => new FlowListItem
                {
                    Id = f.Id,
                    Name = f.Name,
                    Description = f.Description ?? "",
                    Deployed = f.Deployed,
                    UpdatedAt = f.UpdatedAt,
                    Definition = f.Definition
                }).ToList();
            }
            else
            {
                // Fall back to sample data if no flows
                FlowsList = GetSampleFlows();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to load flows: {ex.Message}");
            // Fall back to sample data
            FlowsList = GetSampleFlows();
        }
        
        IsLoading = false;
    }
    
    private void LoadFlowDefinition(FlowListItem flow)
    {
        // Load existing nodes from flow definition
        // Parse the JSON definition and create nodes/connectors
        if (!string.IsNullOrEmpty(flow.Definition) && flow.Definition != "{}")
        {
            try
            {
                // Set flag to prevent OnNodeCreating from regenerating IDs
                // This flag will be cleared in OnAfterRenderAsync after connectors are added
                _isLoadingFlowDefinition = true;
                
                // Deserialize flow definition
                using var doc = System.Text.Json.JsonDocument.Parse(flow.Definition);
                var root = doc.RootElement;
                
                // Clear existing nodes and connectors
                Nodes = new DiagramObjectCollection<Node>();
                Connectors = new DiagramObjectCollection<Connector>();
                _pendingConnectors = new DiagramObjectCollection<Connector>();
                _nodeTypes = new Dictionary<string, string>(); // Clear node type mappings
                _nodeProperties = new Dictionary<string, Dictionary<string, string>>(); // Clear node properties
                
                // Load nodes
                if (root.TryGetProperty("nodes", out var nodesElement))
                {
                    foreach (var nodeDef in nodesElement.EnumerateArray())
                    {
                        // Safe ID extraction
                        var id = nodeDef.TryGetProperty("id", out var idProp) ? idProp.GetString() ?? "" : "";
                        
                        // Try direct x/y first, then fall back to position object
                        double x = 0, y = 0;
                        if (nodeDef.TryGetProperty("x", out var xProp))
                        {
                            x = xProp.GetDouble();
                        }
                        else if (nodeDef.TryGetProperty("position", out var posProp))
                        {
                            if (posProp.TryGetProperty("x", out var posX))
                                x = posX.GetDouble();
                        }
                        
                        if (nodeDef.TryGetProperty("y", out var yProp))
                        {
                            y = yProp.GetDouble();
                        }
                        else if (nodeDef.TryGetProperty("position", out var posPropy))
                        {
                            if (posPropy.TryGetProperty("y", out var posY))
                                y = posY.GetDouble();
                        }
                        
                        var label = nodeDef.TryGetProperty("label", out var labelProp) ? labelProp.GetString() : id;
                        var nodeType = nodeDef.TryGetProperty("type", out var typeProp) ? typeProp.GetString() : "";
                        
                        // Get plugin for this node type to determine color and port counts
                        var plugin = NodeRegistry.Get(nodeType ?? "unknown");
                        var color = plugin?.Color ?? "#9ca3af";
                        var inputCount = plugin?.InputCount ?? 1;
                        var outputCount = plugin?.OutputCount ?? 1;
                        
                        var node = CreateFlowNode(id, label ?? id, color, x, y, inputCount, outputCount);
                        Nodes.Add(node);
                        
                        // Store the node type mapping for property panel lookup
                        if (!string.IsNullOrEmpty(nodeType))
                        {
                            _nodeTypes[id] = nodeType;
                        }
                        
                        // Load node config into _nodeProperties for editing
                        if (nodeDef.TryGetProperty("config", out var configElement))
                        {
                            if (!_nodeProperties.ContainsKey(id))
                            {
                                _nodeProperties[id] = new Dictionary<string, string>();
                            }
                            
                            // Iterate through config properties and store them
                            foreach (var configProp in configElement.EnumerateObject())
                            {
                                var propValue = configProp.Value.ValueKind switch
                                {
                                    System.Text.Json.JsonValueKind.String => configProp.Value.GetString() ?? "",
                                    System.Text.Json.JsonValueKind.Number => configProp.Value.GetRawText(),
                                    System.Text.Json.JsonValueKind.True => "true",
                                    System.Text.Json.JsonValueKind.False => "false",
                                    System.Text.Json.JsonValueKind.Array => System.Text.Json.JsonSerializer.Serialize(configProp.Value),
                                    System.Text.Json.JsonValueKind.Object => System.Text.Json.JsonSerializer.Serialize(configProp.Value),
                                    _ => configProp.Value.GetRawText()
                                };
                                _nodeProperties[id][configProp.Name] = propValue;
                            }
                        }
                    }
                }
                
                // Load connectors - add to pending list to avoid 0,0 positioning
                // Try both "connectors" and "edges" names
                System.Text.Json.JsonElement connectorsElement;
                bool hasConnectors = root.TryGetProperty("connectors", out connectorsElement);
                if (!hasConnectors)
                {
                    hasConnectors = root.TryGetProperty("edges", out connectorsElement);
                }
                
                if (hasConnectors)
                {
                    foreach (var connDef in connectorsElement.EnumerateArray())
                    {
                        // Safe property extraction with fallbacks for different naming conventions
                        var id = connDef.TryGetProperty("id", out var idProp) ? idProp.GetString() ?? "" : "";
                        
                        var sourceId = connDef.TryGetProperty("sourceId", out var srcId) ? srcId.GetString() ?? "" :
                                      connDef.TryGetProperty("source", out var src) ? src.GetString() ?? "" : "";
                        
                        var targetId = connDef.TryGetProperty("targetId", out var tgtId) ? tgtId.GetString() ?? "" :
                                      connDef.TryGetProperty("target", out var tgt) ? tgt.GetString() ?? "" : "";
                        
                        var sourcePort = connDef.TryGetProperty("sourcePort", out var srcPort) ? srcPort.GetString() : 
                                        connDef.TryGetProperty("sourceHandle", out var srcHandle) ? srcHandle.GetString() : null;
                        
                        var targetPort = connDef.TryGetProperty("targetPort", out var tgtPort) ? tgtPort.GetString() :
                                        connDef.TryGetProperty("targetHandle", out var tgtHandle) ? tgtHandle.GetString() : null;
                        
                        // Map semantic port names to indexed port names
                        // The database uses names like "input1", "value", "numerator" but 
                        // Syncfusion Diagram uses "input-0", "input-1", "output-0"
                        var mappedSourcePort = MapPortName(sourcePort, "output");
                        var mappedTargetPort = MapPortName(targetPort, "input");
                        
                        var connector = CreateFlowConnector(id, sourceId, mappedSourcePort, targetId, mappedTargetPort);
                        _pendingConnectors.Add(connector);
                    }
                }
                
                // Reset the connectors added flag so OnAfterRenderAsync will add the pending connectors
                _connectorsAdded = false;
            }
            catch (System.Text.Json.JsonException ex)
            {
                Console.WriteLine($"JSON parsing error in flow definition: {ex.Message}");
                // Fall back to hardcoded sample for demo purposes
                LoadSampleFlowDefinition(flow);
            }
            catch (KeyNotFoundException ex)
            {
                Console.WriteLine($"Missing required property in flow definition: {ex.Message}");
                LoadSampleFlowDefinition(flow);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to load flow definition: {ex.Message}");
                Console.WriteLine($"Stack trace: {ex.StackTrace}");
                // Fall back to hardcoded sample for demo purposes
                LoadSampleFlowDefinition(flow);
            }
            // Note: DO NOT clear _isLoadingFlowDefinition here - it will be cleared in OnAfterRenderAsync
            // after connectors are added, because OnNodeCreating events fire asynchronously during render
        }
        else
        {
            // No definition or empty - start with empty canvas
            Nodes = new DiagramObjectCollection<Node>();
            Connectors = new DiagramObjectCollection<Connector>();
            _pendingConnectors = new DiagramObjectCollection<Connector>();
        }
    }
    
    private void LoadSampleFlowDefinition(FlowListItem flow)
    {
        // Set flag to prevent OnNodeCreating from regenerating IDs
        _isLoadingFlowDefinition = true;
        
        try
        {
            // For demo, add some sample nodes for the Temperature Monitor flow
            if (flow.Name == "Temperature Monitor")
            {
                Nodes = new DiagramObjectCollection<Node>
                {
                    CreateFlowNode("trigger-manual-1", "Manual Trigger", "#4caf50", 150, 150, 0, 1),
                    CreateFlowNode("tag-input-1", "Tag Input", "#2196f3", 350, 150, 1, 1),
                    CreateFlowNode("compare-greater-1", "Greater Than", "#607d8b", 550, 150, 2, 1),
                    CreateFlowNode("notification-1", "Notification", "#e91e63", 750, 150, 1, 0)
                };
                
                // Store connectors to be added after diagram renders
                // This avoids the issue where connectors appear at (0,0) before nodes are rendered
                _pendingConnectors = new DiagramObjectCollection<Connector>
                {
                    CreateFlowConnector("conn-1", "trigger-manual-1", "output-0", "tag-input-1", "input-0"),
                    CreateFlowConnector("conn-2", "tag-input-1", "output-0", "compare-greater-1", "input-0"),
                    CreateFlowConnector("conn-3", "compare-greater-1", "output-0", "notification-1", "input-0")
                };
                
                // Clear the main Connectors collection - we'll add them programmatically after render
                Connectors = new DiagramObjectCollection<Connector>();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in LoadSampleFlowDefinition: {ex.Message}");
        }
        // Note: DO NOT clear _isLoadingFlowDefinition here - it will be cleared in OnAfterRenderAsync
    }
    
    /// <summary>
    /// Gets the icon for a node type from the plugin registry
    /// </summary>
    private string GetNodeIcon(string nodeType)
    {
        var baseType = nodeType.Split("-instance-").FirstOrDefault() ?? nodeType;
        var plugin = NodeRegistry.Get(baseType);
        return plugin?.Icon ?? "[?]";
    }
    
    /// <summary>
    /// Gets color for a node type from the plugin registry
    /// </summary>
    private string GetNodeColor(string nodeType)
    {
        var baseType = nodeType.Split("-instance-").FirstOrDefault() ?? nodeType;
        var plugin = NodeRegistry.Get(baseType);
        return plugin?.Color ?? "#9ca3af";
    }
    
    /// <summary>
    /// Creates a flow node with HTML template styling similar to the original React app
    /// </summary>
    private Node CreateFlowNode(string id, string label, string color, double x, double y, int inputCount, int outputCount)
    {
        var baseType = id.Split("-instance-").FirstOrDefault()?.Replace("-1", "").Replace("-2", "") ?? id;
        var icon = GetNodeIcon(baseType);
        
        var node = new Node
        {
            ID = id,
            OffsetX = x,
            OffsetY = y,
            Width = 180,
            Height = 70,
            Shape = new BasicShape { Type = NodeShapes.Basic, Shape = NodeBasicShapes.Rectangle, CornerRadius = 8 },
            Style = new ShapeStyle { Fill = "#2a2a2a", StrokeColor = color, StrokeWidth = 2 },
            Annotations = new DiagramObjectCollection<ShapeAnnotation>(),
            Ports = new DiagramObjectCollection<PointPort>(),
            // Enable all node interactions: drag, resize, select, delete
            Constraints = NodeConstraints.Default | NodeConstraints.AllowDrop
        };
        
        // Create HTML-like multi-line annotation with icon and label
        node.Annotations.Add(new ShapeAnnotation
        {
            Content = $"{icon}  {label}",
            Style = new TextStyle 
            { 
                Color = "#ffffff", 
                FontSize = 13, 
                Bold = true,
                FontFamily = "Segoe UI, -apple-system, BlinkMacSystemFont, Roboto, sans-serif"
            },
            Offset = new DiagramPoint { X = 0.5, Y = 0.35 },
            HorizontalAlignment = HorizontalAlignment.Center
        });
        
        // Add category/type subtitle
        var pluginInfo = NodeRegistry.Get(baseType);
        var category = pluginInfo?.Category ?? "Node";
        node.Annotations.Add(new ShapeAnnotation
        {
            Content = category,
            Style = new TextStyle 
            { 
                Color = "#9d9d9d", 
                FontSize = 10, 
                Italic = true,
                FontFamily = "Segoe UI, -apple-system, BlinkMacSystemFont, Roboto, sans-serif"
            },
            Offset = new DiagramPoint { X = 0.5, Y = 0.7 },
            HorizontalAlignment = HorizontalAlignment.Center
        });
        
        // Add colored accent bar at top
        node.Annotations.Add(new ShapeAnnotation
        {
            Content = "",
            Style = new TextStyle { Color = color },
            Offset = new DiagramPoint { X = 0.5, Y = 0.02 }
        });
        
        // Add input ports (left side) - styled like React app
        for (int i = 0; i < inputCount; i++)
        {
            var yOffset = inputCount == 1 ? 0.5 : (i + 1.0) / (inputCount + 1);
            node.Ports.Add(new PointPort
            {
                ID = $"input-{i}",
                Offset = new DiagramPoint { X = 0, Y = yOffset },
                Visibility = PortVisibility.Visible,
                Shape = PortShapes.Circle,
                Width = 14,
                Height = 14,
                Style = new ShapeStyle { Fill = "#2196f3", StrokeColor = "#ffffff", StrokeWidth = 2 },
                Constraints = PortConstraints.Default | PortConstraints.Draw
            });
        }
        
        // Add output ports (right side) - styled like React app
        for (int i = 0; i < outputCount; i++)
        {
            var yOffset = outputCount == 1 ? 0.5 : (i + 1.0) / (outputCount + 1);
            node.Ports.Add(new PointPort
            {
                ID = $"output-{i}",
                Offset = new DiagramPoint { X = 1, Y = yOffset },
                Visibility = PortVisibility.Visible,
                Shape = PortShapes.Circle,
                Width = 14,
                Height = 14,
                Style = new ShapeStyle { Fill = "#ff9800", StrokeColor = "#ffffff", StrokeWidth = 2 },
                Constraints = PortConstraints.Default | PortConstraints.Draw
            });
        }
        
        return node;
    }
    
    /// <summary>
    /// Maps semantic port names from flow definitions to actual port IDs
    /// Database uses names like "input1", "value", "numerator" but Syncfusion uses "input-0", "output-0"
    /// </summary>
    private string MapPortName(string? portName, string portType)
    {
        if (string.IsNullOrEmpty(portName))
        {
            return $"{portType}-0";
        }
        
        // If it's already in the correct format (input-0, output-0), return as-is
        if (portName.StartsWith("input-") || portName.StartsWith("output-"))
        {
            return portName;
        }
        
        // Map semantic names to indexed names
        // Common patterns: input1, input2, value, numerator, denominator, etc.
        if (portName.StartsWith("input") && portName.Length > 5 && int.TryParse(portName.Substring(5), out var inputNum))
        {
            // "input1" -> "input-0", "input2" -> "input-1"
            return $"input-{inputNum - 1}";
        }
        
        if (portName.StartsWith("output") && portName.Length > 6 && int.TryParse(portName.Substring(6), out var outputNum))
        {
            // "output1" -> "output-0", "output2" -> "output-1"
            return $"output-{outputNum - 1}";
        }
        
        // For other semantic names, map to first port of appropriate type
        // This handles names like "value", "numerator", "highAlert", etc.
        return $"{portType}-0";
    }
    
    /// <summary>
    /// Creates a connector between two ports
    /// </summary>
    private Connector CreateFlowConnector(string id, string sourceId, string? sourcePort, string targetId, string? targetPort)
    {
        return new Connector
        {
            ID = id,
            SourceID = sourceId,
            SourcePortID = sourcePort ?? "output-0",
            TargetID = targetId,
            TargetPortID = targetPort ?? "input-0",
            Type = ConnectorSegmentType.Orthogonal,
            Style = new ShapeStyle { StrokeColor = "#4caf50", StrokeWidth = 2 },
            TargetDecorator = new DecoratorSettings 
            { 
                Shape = DecoratorShape.Arrow, 
                Style = new ShapeStyle { Fill = "#4caf50", StrokeColor = "#4caf50" },
                Width = 10,
                Height = 10
            },
            CornerRadius = 5
        };
    }
    
    private async Task CreateNewFlow()
    {
        var newId = Guid.NewGuid();
        try
        {
            // Create flow in database
            var flow = await DataService.CreateFlowAsync(
                "New Flow",
                "New flow description",
                "{}",
                Guid.Empty // Will use default owner
            );
            if (flow != null)
            {
                newId = flow.Id;
                Navigation.NavigateTo($"/flows/{newId}");
            }
            else
            {
                // Fallback to local ID
                Navigation.NavigateTo($"/flows/{newId}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to create flow: {ex.Message}");
            // Still navigate to allow local editing
            Navigation.NavigateTo($"/flows/{newId}");
        }
    }
    
    private void EditFlow(Guid id)
    {
        Navigation.NavigateTo($"/flows/{id}");
    }
    
    private async Task DeleteFlow(Guid id)
    {
        try
        {
            // Delete from database
            var success = await DataService.DeleteFlowAsync(id);
            if (success)
            {
                FlowsList.RemoveAll(f => f.Id == id);
                StateHasChanged();
            }
            else
            {
                // Fallback - still remove locally
                FlowsList.RemoveAll(f => f.Id == id);
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to delete flow: {ex.Message}");
            // Still remove locally for demo purposes
            FlowsList.RemoveAll(f => f.Id == id);
            StateHasChanged();
        }
    }
    
    private void GoBack()
    {
        Navigation.NavigateTo("/flows");
    }
    
    private async Task ToggleDeploy()
    {
        var newDeployState = !CurrentFlow.Deployed;
        try
        {
            // Deploy/undeploy via DataService
            var success = await DataService.DeployFlowAsync(CurrentFlow.Id, newDeployState);
            if (success)
            {
                CurrentFlow.Deployed = newDeployState;
                _saveMessage = CurrentFlow.Deployed ? "Flow deployed successfully!" : "Flow stopped.";
                _showSaveMessage = true;
                StateHasChanged();
                // Hide message after 3 seconds using timer
                _messageTimer?.Dispose();
                _messageTimer = new Timer(HideMessage, null, 3000, Timeout.Infinite);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to deploy flow: {ex.Message}");
            // Fall back to local state change
            CurrentFlow.Deployed = newDeployState;
        }
    }
    
    private string _saveMessage = "";
    private bool _showSaveMessage = false;
    
    private async Task SaveFlow()
    {
        // Save flow to database - serialize nodes and connectors
        if (Diagram != null)
        {
            try
            {
                // Serialize the diagram state to JSON
                var definition = SerializeFlowDefinition();
                
                // Update via DataService
                var success = await DataService.UpdateFlowAsync(
                    CurrentFlow.Id,
                    CurrentFlow.Name,
                    CurrentFlow.Description,
                    definition,
                    null, // executionMode
                    null, // scanRateMs
                    null, // shared
                    null  // testMode
                );
                
                if (success)
                {
                    CurrentFlow.UpdatedAt = DateTime.Now;
                    _saveMessage = "Flow saved successfully!";
                }
                else
                {
                    _saveMessage = "Flow saved locally (save failed)";
                    CurrentFlow.UpdatedAt = DateTime.Now;
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Failed to save flow: {ex.Message}");
                _saveMessage = "Flow saved locally (error)";
                CurrentFlow.UpdatedAt = DateTime.Now;
            }
            
            _showSaveMessage = true;
            StateHasChanged();;
            
            // Hide message after 3 seconds using timer
            _messageTimer?.Dispose();
            _messageTimer = new Timer(HideMessage, null, 3000, Timeout.Infinite);
        }
    }
    
    private System.Threading.Timer? _messageTimer;
    
    private void HideMessage(object? state)
    {
        _showSaveMessage = false;
        InvokeAsync(StateHasChanged);
    }
    
    private string SerializeFlowDefinition()
    {
        // Serialize nodes and connectors to JSON format
        var flowDef = new
        {
            nodes = Nodes.Select(n => new
            {
                id = n.ID,
                x = n.OffsetX,
                y = n.OffsetY,
                type = n.ID?.Split("-instance-").FirstOrDefault() ?? "unknown",
                label = n.Annotations?.FirstOrDefault()?.Content ?? n.ID,
                width = n.Width,
                height = n.Height
            }).ToList(),
            connectors = Connectors.Select(c => new
            {
                id = c.ID,
                sourceId = c.SourceID,
                sourcePort = c.SourcePortID,
                targetId = c.TargetID,
                targetPort = c.TargetPortID
            }).ToList()
        };
        
        return System.Text.Json.JsonSerializer.Serialize(flowDef);
    }
    
    private void OnNodeCreating(IDiagramObject obj)
    {
        if (obj is Node node)
        {
            // Set proper size for dropped nodes matching our design
            node.Width = 180;
            node.Height = 70;
            
            // Ensure node has full interactivity (drag, select, resize, delete)
            node.Constraints = NodeConstraints.Default | NodeConstraints.AllowDrop;
            
            // Generate unique ID if not already an instance AND we're not loading a flow definition
            // During flow loading, we preserve the exact IDs from the definition to maintain connector references
            if (node.ID != null && !node.ID.Contains("-instance-") && !_isLoadingFlowDefinition)
            {
                var baseId = node.ID;
                node.ID = $"{baseId}-instance-{Guid.NewGuid():N}";
                
                // Get category for subtitle from plugin registry
                var pluginDef = NodeRegistry.Get(baseId);
                var category = pluginDef?.Category ?? "Node";
                var icon = GetNodeIcon(baseId);
                var label = node.Annotations?.FirstOrDefault()?.Content?.ToString()?.Replace($"{icon}  ", "") ?? baseId;
                
                // Update styling to match flow nodes (dark background with colored border)
                node.Style = new ShapeStyle { Fill = "#2a2a2a", StrokeColor = node.Style?.StrokeColor ?? "#4caf50", StrokeWidth = 2 };
                
                // Clear and recreate annotations for proper styling
                node.Annotations = new DiagramObjectCollection<ShapeAnnotation>
                {
                    new ShapeAnnotation
                    {
                        Content = $"{icon}  {label}",
                        Style = new TextStyle 
                        { 
                            Color = "#ffffff", 
                            FontSize = 13, 
                            Bold = true,
                            FontFamily = "Segoe UI, -apple-system, BlinkMacSystemFont, Roboto, sans-serif"
                        },
                        Offset = new DiagramPoint { X = 0.5, Y = 0.35 },
                        HorizontalAlignment = HorizontalAlignment.Center
                    },
                    new ShapeAnnotation
                    {
                        Content = category,
                        Style = new TextStyle 
                        { 
                            Color = "#9d9d9d", 
                            FontSize = 10, 
                            Italic = true,
                            FontFamily = "Segoe UI, -apple-system, BlinkMacSystemFont, Roboto, sans-serif"
                        },
                        Offset = new DiagramPoint { X = 0.5, Y = 0.7 },
                        HorizontalAlignment = HorizontalAlignment.Center
                    }
                };
            }
            
            // Ensure ports are visible and enabled for connections
            if (node.Ports != null)
            {
                foreach (var port in node.Ports)
                {
                    port.Visibility = PortVisibility.Visible;
                    port.Width = 14;
                    port.Height = 14;
                    port.Constraints = PortConstraints.Default | PortConstraints.Draw;
                }
            }
        }
    }
    
    private void OnConnectorCreating(IDiagramObject obj)
    {
        if (obj is Connector connector)
        {
            connector.Type = ConnectorSegmentType.Orthogonal;
            connector.Style = new ShapeStyle { StrokeColor = "#4caf50", StrokeWidth = 2 };
            connector.CornerRadius = 5;
            connector.TargetDecorator = new DecoratorSettings 
            { 
                Shape = DecoratorShape.Arrow,
                Width = 10,
                Height = 10,
                Style = new ShapeStyle { Fill = "#4caf50", StrokeColor = "#4caf50" } 
            };
        }
    }
    
    private void OnSelectionChanged(Syncfusion.Blazor.Diagram.SelectionChangedEventArgs args)
    {
        // Get selected nodes from the diagram
        if (Diagram?.SelectionSettings?.Nodes?.Count > 0)
        {
            SelectedNode = Diagram.SelectionSettings.Nodes[0] as Node;
            if (SelectedNode?.Annotations?.Count > 0)
            {
                SelectedNodeLabel = SelectedNode.Annotations[0].Content ?? "";
            }
        }
        else
        {
            SelectedNode = null;
            SelectedNodeLabel = "";
        }
    }
    
    private string GetNodeType(Node node)
    {
        var id = node.ID ?? "";
        
        // First check if we have a stored node type from loading
        if (_nodeTypes.TryGetValue(id, out var storedType) && !string.IsNullOrEmpty(storedType))
        {
            return storedType.ToUpper().Replace("-", " ");
        }
        
        var parts = id.Split("-instance-").FirstOrDefault()?.Split('-') ?? Array.Empty<string>();
        return string.Join(" ", parts.Take(2)).ToUpper();
    }
    
    private string GetNodeBaseType(Node node)
    {
        var id = node.ID ?? "";
        
        // First check if we have a stored node type from loading
        if (_nodeTypes.TryGetValue(id, out var storedType) && !string.IsNullOrEmpty(storedType))
        {
            return storedType;
        }
        
        return id.Split("-instance-").FirstOrDefault() ?? "unknown";
    }
    
    private string GetMathOperation(Node node)
    {
        var baseType = GetNodeBaseType(node);
        return baseType switch
        {
            "math-add" => "Add (+)",
            "math-subtract" => "Subtract (-)",
            "math-multiply" => "Multiply (×)",
            "math-divide" => "Divide (÷)",
            _ => "Unknown"
        };
    }
    
    private string GetComparisonType(Node node)
    {
        var baseType = GetNodeBaseType(node);
        return baseType switch
        {
            "compare-equal" => "Equal (==)",
            "compare-greater" => "Greater Than (>)",
            "compare-less" => "Less Than (<)",
            "logic-if" => "If/Else Conditional",
            _ => "Comparison"
        };
    }
    
    // Node property storage for node-specific settings
    private Dictionary<string, Dictionary<string, string>> _nodeProperties = new();
    private bool _showAdvanced = false;
    
    // Dropdown options for node properties (kept for backward compatibility)
    private List<string> NotificationSeverities = new() { "Info", "Warning", "Error", "Critical" };
    private List<string> NotificationChannels = new() { "App", "Email", "SMS", "Webhook" };
    private List<string> LogLevels = new() { "Debug", "Info", "Warning", "Error" };
    private List<string> DataTypes = new() { "Float", "Integer", "Boolean", "String" };
    private List<string> TriggerModes = new() { "Any Change", "Rising Edge", "Falling Edge", "Value Match" };
    
    /// <summary>
    /// Renders the appropriate input control based on property type from plugin metadata
    /// </summary>
    private RenderFragment RenderPropertyInput(NodePropertyDefinition prop) => builder =>
    {
        var value = GetNodeProperty(prop.Key, prop.DefaultValue);
        
        switch (prop.Type)
        {
            case PropertyType.Text:
            case PropertyType.TagPath:
            case PropertyType.Cron:
                builder.OpenComponent<SfTextBox>(0);
                builder.AddAttribute(1, "Value", value);
                builder.AddAttribute(2, "ValueChanged", EventCallback.Factory.Create<string>(this, v => SetNodeProperty(prop.Key, v)));
                builder.AddAttribute(3, "Placeholder", prop.Placeholder);
                builder.CloseComponent();
                break;
                
            case PropertyType.TextArea:
            case PropertyType.Json:
                builder.OpenComponent<SfTextBox>(0);
                builder.AddAttribute(1, "Value", value);
                builder.AddAttribute(2, "ValueChanged", EventCallback.Factory.Create<string>(this, v => SetNodeProperty(prop.Key, v)));
                builder.AddAttribute(3, "Placeholder", prop.Placeholder);
                builder.AddAttribute(4, "Multiline", true);
                builder.CloseComponent();
                break;
                
            case PropertyType.Integer:
                builder.OpenComponent<SfNumericTextBox<int>>(0);
                builder.AddAttribute(1, "Value", int.TryParse(value, out var intVal) ? intVal : 0);
                builder.AddAttribute(2, "ValueChanged", EventCallback.Factory.Create<int>(this, v => SetNodeProperty(prop.Key, v.ToString())));
                if (prop.Min.HasValue) builder.AddAttribute(3, "Min", (int)prop.Min.Value);
                if (prop.Max.HasValue) builder.AddAttribute(4, "Max", (int)prop.Max.Value);
                if (prop.Step.HasValue) builder.AddAttribute(5, "Step", (int)prop.Step.Value);
                builder.CloseComponent();
                break;
                
            case PropertyType.Decimal:
                builder.OpenComponent<SfNumericTextBox<double>>(0);
                builder.AddAttribute(1, "Value", double.TryParse(value, out var dblVal) ? dblVal : 0);
                builder.AddAttribute(2, "ValueChanged", EventCallback.Factory.Create<double>(this, v => SetNodeProperty(prop.Key, v.ToString())));
                if (prop.Min.HasValue) builder.AddAttribute(3, "Min", prop.Min.Value);
                if (prop.Max.HasValue) builder.AddAttribute(4, "Max", prop.Max.Value);
                if (prop.Step.HasValue) builder.AddAttribute(5, "Step", prop.Step.Value);
                builder.CloseComponent();
                break;
                
            case PropertyType.Boolean:
                builder.OpenComponent<SfCheckBox<bool>>(0);
                builder.AddAttribute(1, "Checked", value.Equals("true", StringComparison.OrdinalIgnoreCase));
                builder.AddAttribute(2, "CheckedChanged", EventCallback.Factory.Create<bool>(this, v => SetNodeProperty(prop.Key, v.ToString().ToLower())));
                builder.AddAttribute(3, "Label", prop.HelpText ?? prop.Label);
                builder.CloseComponent();
                break;
                
            case PropertyType.Select:
                // Use SelectOption list with text/value fields for proper label display
                builder.OpenComponent<SfDropDownList<string, SelectOption>>(0);
                builder.AddAttribute(1, "DataSource", prop.Options);
                builder.AddAttribute(2, "Value", string.IsNullOrEmpty(value) ? prop.DefaultValue : value);
                builder.AddAttribute(3, "ValueChanged", EventCallback.Factory.Create<string>(this, v => SetNodeProperty(prop.Key, v)));
                builder.AddAttribute(4, "TValue", typeof(string));
                builder.AddAttribute(5, "TItem", typeof(SelectOption));
                builder.AddAttribute(6, "TextField", "Label");
                builder.AddAttribute(7, "ValueField", "Value");
                builder.CloseComponent();
                break;
                
            case PropertyType.Color:
                // Color picker fallback to text input with color format hint
                builder.OpenComponent<SfTextBox>(0);
                builder.AddAttribute(1, "Value", value);
                builder.AddAttribute(2, "ValueChanged", EventCallback.Factory.Create<string>(this, v => SetNodeProperty(prop.Key, v)));
                builder.AddAttribute(3, "Placeholder", "#RRGGBB");
                builder.CloseComponent();
                break;
                
            case PropertyType.ReadOnly:
                builder.OpenElement(0, "span");
                builder.AddAttribute(1, "class", "property-value");
                builder.AddContent(2, value);
                builder.CloseElement();
                break;
            
            case PropertyType.Code:
                // Code editor - use a multiline text box with monospace font styling
                builder.OpenComponent<SfTextBox>(0);
                builder.AddAttribute(1, "Value", value);
                builder.AddAttribute(2, "ValueChanged", EventCallback.Factory.Create<string>(this, v => SetNodeProperty(prop.Key, v)));
                builder.AddAttribute(3, "Placeholder", prop.Placeholder);
                builder.AddAttribute(4, "Multiline", true);
                builder.AddAttribute(5, "CssClass", "code-editor");
                builder.CloseComponent();
                break;
                
            default:
                builder.OpenComponent<SfTextBox>(0);
                builder.AddAttribute(1, "Value", value);
                builder.AddAttribute(2, "ValueChanged", EventCallback.Factory.Create<string>(this, v => SetNodeProperty(prop.Key, v)));
                builder.CloseComponent();
                break;
        }
    };
    
    // Property change handlers
    private async Task OnLabelChanged(string newLabel)
    {
        if (SelectedNode != null && Diagram != null)
        {
            SelectedNodeLabel = newLabel;
            
            // Extract icon from current content
            var currentContent = SelectedNode.Annotations?.FirstOrDefault()?.Content ?? "";
            var icon = currentContent.Length >= 2 ? currentContent.Substring(0, 2) : "📦";
            
            // Update the node's first annotation
            if (SelectedNode.Annotations?.Count > 0)
            {
                SelectedNode.Annotations[0].Content = $"{icon}  {newLabel}";
            }
            
            // Refresh the diagram
            StateHasChanged();
            await Task.CompletedTask;
        }
    }
    
    private async Task OnPositionXChanged(double newX)
    {
        if (SelectedNode != null && Diagram != null)
        {
            SelectedNode.OffsetX = newX;
            StateHasChanged();
            await Task.CompletedTask;
        }
    }
    
    private async Task OnPositionYChanged(double newY)
    {
        if (SelectedNode != null && Diagram != null)
        {
            SelectedNode.OffsetY = newY;
            StateHasChanged();
            await Task.CompletedTask;
        }
    }
    
    private async Task OnWidthChanged(double newWidth)
    {
        if (SelectedNode != null && Diagram != null)
        {
            SelectedNode.Width = newWidth;
            StateHasChanged();
            await Task.CompletedTask;
        }
    }
    
    private async Task OnHeightChanged(double newHeight)
    {
        if (SelectedNode != null && Diagram != null)
        {
            SelectedNode.Height = newHeight;
            StateHasChanged();
            await Task.CompletedTask;
        }
    }
    
    // Get/Set node-specific properties
    private string GetNodeProperty(string key, string defaultValue = "")
    {
        if (SelectedNode == null) return defaultValue;
        
        var nodeId = SelectedNode.ID ?? "";
        if (_nodeProperties.TryGetValue(nodeId, out var props) && props.TryGetValue(key, out var value))
        {
            return value;
        }
        return defaultValue;
    }
    
    private double GetDoubleProperty(string key, double defaultValue = 0)
    {
        var strValue = GetNodeProperty(key, defaultValue.ToString());
        return double.TryParse(strValue, out var val) ? val : defaultValue;
    }
    
    private int GetIntProperty(string key, int defaultValue = 0)
    {
        var strValue = GetNodeProperty(key, defaultValue.ToString());
        return int.TryParse(strValue, out var val) ? val : defaultValue;
    }
    
    private void SetNodeProperty(string key, string value)
    {
        if (SelectedNode == null) return;
        
        var nodeId = SelectedNode.ID ?? "";
        if (!_nodeProperties.ContainsKey(nodeId))
        {
            _nodeProperties[nodeId] = new Dictionary<string, string>();
        }
        _nodeProperties[nodeId][key] = value;
        StateHasChanged();
    }
    
    private double GetThresholdValue()
    {
        var strValue = GetNodeProperty("threshold", "50");
        return double.TryParse(strValue, out var val) ? val : 50;
    }
    
    private void OnThresholdChanged(double newValue)
    {
        SetNodeProperty("threshold", newValue.ToString());
    }
    
    private int GetIntervalValue()
    {
        var strValue = GetNodeProperty("interval", "60");
        return int.TryParse(strValue, out var val) ? val : 60;
    }
    
    private void OnIntervalChanged(int newValue)
    {
        SetNodeProperty("interval", newValue.ToString());
    }
    
    private async Task DeleteSelectedNode()
    {
        if (SelectedNode != null && Diagram != null)
        {
            var nodeId = SelectedNode.ID;
            
            // Remove any connectors connected to this node
            var connectorsToRemove = Connectors.Where(c => c.SourceID == nodeId || c.TargetID == nodeId).ToList();
            foreach (var connector in connectorsToRemove)
            {
                Connectors.Remove(connector);
            }
            
            // Remove the node
            Nodes.Remove(SelectedNode);
            
            // Clear selection
            SelectedNode = null;
            SelectedNodeLabel = "";
            
            // Remove node properties
            if (nodeId != null)
            {
                _nodeProperties.Remove(nodeId);
            }
            
            StateHasChanged();
            await Task.CompletedTask;
        }
    }
    
    private List<FlowListItem> GetSampleFlows()
    {
        return new List<FlowListItem>
        {
            new() { 
                Id = Guid.Parse("11111111-1111-1111-1111-111111111111"), 
                Name = "Temperature Monitor", 
                Description = "Monitors tank temperatures and triggers alarms", 
                Deployed = true, 
                UpdatedAt = DateTime.Now.AddHours(-2),
                Definition = @"{""nodes"":[{""id"":""trigger-1"",""x"":150,""y"":150,""type"":""trigger-manual""},{""id"":""tag-1"",""x"":350,""y"":150,""type"":""tag-input""}],""connectors"":[{""sourceId"":""trigger-1"",""targetId"":""tag-1""}]}"
            },
            new() { 
                Id = Guid.Parse("22222222-2222-2222-2222-222222222222"), 
                Name = "Pressure Alarm", 
                Description = "Sends alerts when pressure exceeds threshold", 
                Deployed = false, 
                UpdatedAt = DateTime.Now.AddDays(-1),
                Definition = "{}"
            },
            new() { 
                Id = Guid.Parse("33333333-3333-3333-3333-333333333333"), 
                Name = "Data Logger", 
                Description = "Logs production data to database every 5 minutes", 
                Deployed = true, 
                UpdatedAt = DateTime.Now.AddMinutes(-30),
                Definition = "{}"
            },
            new() { 
                Id = Guid.Parse("44444444-4444-4444-4444-444444444444"), 
                Name = "Tank Level Controller", 
                Description = "Maintains tank levels within specified range", 
                Deployed = true, 
                UpdatedAt = DateTime.Now.AddHours(-6),
                Definition = "{}"
            },
            new() { 
                Id = Guid.Parse("55555555-5555-5555-5555-555555555555"), 
                Name = "Batch Report Generator", 
                Description = "Generates production reports at end of shift", 
                Deployed = false, 
                UpdatedAt = DateTime.Now.AddDays(-3),
                Definition = "{}"
            }
        };
    }
    
    class FlowListItem
    {
        public Guid Id { get; set; }
        public string Name { get; set; } = "";
        public string Description { get; set; } = "";
        public bool Deployed { get; set; }
        public string Status => Deployed ? "Deployed" : "Stopped";
        public DateTime UpdatedAt { get; set; }
        public string Definition { get; set; } = "{}";
    }
}
