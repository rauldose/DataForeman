@page "/flows"
@page "/flows/{FlowId:guid}"
@rendermode InteractiveServer

<PageTitle>Flow Studio - DataForeman</PageTitle>

<div class="flows-page">
    @if (FlowId == Guid.Empty)
    {
        <div class="page-header">
            <h1>Flow Studio</h1>
            <div class="page-actions">
                <SfButton CssClass="e-primary" IconCss="e-icons e-plus" Content="New Flow" OnClick="@CreateNewFlow"></SfButton>
            </div>
        </div>
        
        @if (IsLoading)
        {
            <div class="loading-indicator">
                <span>Loading flows...</span>
            </div>
        }
        else
        {
            <SfGrid DataSource="@FlowsList" AllowPaging="true" AllowSorting="true" AllowFiltering="true">
                <GridColumns>
                    <GridColumn Field="@nameof(FlowItem.Name)" HeaderText="Name" Width="200"></GridColumn>
                    <GridColumn Field="@nameof(FlowItem.Description)" HeaderText="Description" Width="300"></GridColumn>
                    <GridColumn Field="@nameof(FlowItem.Status)" HeaderText="Status" Width="100">
                        <Template>
                            @{
                                var flow = context as FlowItem;
                                if (flow != null)
                                {
                                    <span class="status-badge @(flow.Deployed ? "deployed" : "stopped")">
                                        @(flow.Deployed ? "Deployed" : "Stopped")
                                    </span>
                                }
                            }
                        </Template>
                    </GridColumn>
                    <GridColumn Field="@nameof(FlowItem.UpdatedAt)" HeaderText="Last Updated" Width="150" Format="g"></GridColumn>
                    <GridColumn HeaderText="Actions" Width="150">
                        <Template>
                            @{
                                var flow = context as FlowItem;
                                if (flow != null)
                                {
                                    <div class="action-buttons">
                                        <SfButton CssClass="e-flat e-small" IconCss="e-icons e-edit" OnClick="@(() => EditFlow(flow.Id))"></SfButton>
                                        <SfButton CssClass="e-flat e-small" IconCss="e-icons e-delete" OnClick="@(() => DeleteFlow(flow.Id))"></SfButton>
                                    </div>
                                }
                            }
                        </Template>
                    </GridColumn>
                </GridColumns>
            </SfGrid>
        }
    }
    else
    {
        <div class="flow-editor">
            <div class="editor-toolbar">
                <SfButton CssClass="e-flat" IconCss="e-icons e-arrow-left" Content="Back" OnClick="@GoBack"></SfButton>
                <SfTextBox @bind-Value="CurrentFlow.Name" Placeholder="Flow Name" CssClass="flow-name-input"></SfTextBox>
                <div class="toolbar-spacer"></div>
                <SfButton CssClass="e-outline" IconCss="e-icons e-play" Content="@(CurrentFlow.Deployed ? "Stop" : "Deploy")" OnClick="@ToggleDeploy"></SfButton>
                <SfButton CssClass="e-primary" IconCss="e-icons e-save" Content="Save" OnClick="@SaveFlow"></SfButton>
            </div>
            
            <div class="editor-container">
                @* Syncfusion Symbol Palette - on the left *@
                <div class="symbol-palette-container">
                    <SfSymbolPaletteComponent @ref="SymbolPalette"
                                              Width="100%"
                                              Height="100%"
                                              Palettes="@Palettes"
                                              SymbolHeight="60"
                                              SymbolWidth="100"
                                              SymbolMargin="@SymbolMargin"
                                              GetSymbolInfo="@GetSymbolInfo">
                    </SfSymbolPaletteComponent>
                </div>
                
                @* Syncfusion Diagram *@
                <div class="diagram-container" id="diagram-space">
                    <SfDiagramComponent @ref="Diagram" 
                                        ID="diagram"
                                        Width="100%" 
                                        Height="100%"
                                        Nodes="@Nodes"
                                        Connectors="@Connectors"
                                        NodeCreating="@OnNodeCreating"
                                        ConnectorCreating="@OnConnectorCreating"
                                        SelectionChanged="@OnSelectionChanged"
                                        DragDrop="@OnDragDrop">
                        <SnapSettings>
                            <HorizontalGridLines LineColor="#e0e0e0" LineDashArray="2,2"></HorizontalGridLines>
                            <VerticalGridLines LineColor="#e0e0e0" LineDashArray="2,2"></VerticalGridLines>
                        </SnapSettings>
                        <ScrollSettings ScrollLimit="ScrollLimitMode.Diagram"></ScrollSettings>
                    </SfDiagramComponent>
                </div>
                
                <div class="properties-panel">
                    <h3>Properties</h3>
                    @if (SelectedNode != null)
                    {
                        <div class="property-group">
                            <label>Node ID</label>
                            <span class="property-value">@SelectedNode.ID</span>
                        </div>
                        <div class="property-group">
                            <label>Type</label>
                            <span class="property-value">@GetNodeType(SelectedNode)</span>
                        </div>
                        <div class="property-group">
                            <label>Label</label>
                            <SfTextBox @bind-Value="SelectedNodeLabel" Placeholder="Enter label"></SfTextBox>
                        </div>
                        <div class="property-group">
                            <label>Position X</label>
                            <SfNumericTextBox TValue="double" Value="@SelectedNode.OffsetX" Min="0"></SfNumericTextBox>
                        </div>
                        <div class="property-group">
                            <label>Position Y</label>
                            <SfNumericTextBox TValue="double" Value="@SelectedNode.OffsetY" Min="0"></SfNumericTextBox>
                        </div>
                    }
                    else
                    {
                        <p class="no-selection">Select a node to view properties</p>
                    }
                </div>
            </div>
        </div>
    }
</div>

<style>
    .flows-page {
        height: 100%;
    }
    
    .page-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 24px;
    }
    
    .page-header h1 {
        margin: 0;
    }
    
    .loading-indicator {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 40px;
        color: #9d9d9d;
        font-style: italic;
    }
    
    .status-badge {
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: 500;
    }
    
    .status-badge.deployed {
        background: #4caf50;
        color: white;
    }
    
    .status-badge.stopped {
        background: #757575;
        color: white;
    }
    
    .action-buttons {
        display: flex;
        gap: 4px;
    }
    
    .flow-editor {
        display: flex;
        flex-direction: column;
        height: calc(100vh - 120px);
    }
    
    .editor-toolbar {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px;
        background: #252526;
        border-bottom: 1px solid #3c3c3c;
    }
    
    .flow-name-input {
        width: 250px;
    }
    
    .toolbar-spacer {
        flex: 1;
    }
    
    .editor-container {
        display: flex;
        flex: 1;
        overflow: hidden;
    }
    
    .symbol-palette-container {
        width: 200px;
        min-width: 200px;
        background: #f5f5f5;
        border-right: 1px solid #ddd;
        order: -1;
        overflow: auto;
    }
    
    .diagram-container {
        flex: 1;
        background: #ffffff;
        min-height: 500px;
    }
    
    .properties-panel {
        width: 280px;
        background: #252526;
        border-left: 1px solid #3c3c3c;
        padding: 12px;
        overflow-y: auto;
    }
    
    .properties-panel h3 {
        margin: 0 0 16px 0;
        font-size: 14px;
        border-bottom: 1px solid #3c3c3c;
        padding-bottom: 8px;
    }
    
    .property-group {
        margin-bottom: 16px;
    }
    
    .property-group label {
        display: block;
        font-size: 12px;
        color: #9d9d9d;
        margin-bottom: 4px;
    }
    
    .property-value {
        font-size: 13px;
        color: #cccccc;
    }
    
    .no-selection {
        color: #9d9d9d;
        font-style: italic;
        font-size: 13px;
    }
    
    /* Syncfusion Symbol Palette styling */
    .e-symbol-palette {
        background: #f5f5f5 !important;
        border: none !important;
    }
    
    .e-symbol-palette .e-palette-header {
        background: #e0e0e0 !important;
        color: #333333 !important;
        border-bottom: 1px solid #ccc !important;
        font-weight: 600;
        padding: 8px 12px;
    }
    
    .e-symbol-palette .e-palette-content {
        background: #f5f5f5 !important;
        padding: 8px;
    }
    
    .e-symbol-palette .e-symbol-draggable {
        background: #ffffff !important;
        border: 1px solid #ddd !important;
        border-radius: 4px !important;
        margin: 4px;
        cursor: grab;
    }
    
    .e-symbol-palette .e-symbol-draggable:hover {
        background: #e8f5e9 !important;
        border-color: #4caf50 !important;
    }
    
    /* Syncfusion Diagram styling */
    .e-diagram {
        background: #fafafa !important;
    }
</style>

@code {
    [Parameter] public Guid FlowId { get; set; }
    [Inject] NavigationManager Navigation { get; set; } = default!;
    
    private SfDiagramComponent? Diagram;
    private SfSymbolPaletteComponent? SymbolPalette;
    
    private DiagramObjectCollection<Node> Nodes = new();
    private DiagramObjectCollection<Connector> Connectors = new();
    private Node? SelectedNode;
    private string SelectedNodeLabel = "";
    
    private DiagramObjectCollection<Palette> Palettes = new();
    private SymbolMargin SymbolMargin = new() { Left = 5, Right = 5, Top = 5, Bottom = 5 };
    
    private FlowItem CurrentFlow = new() { Name = "New Flow" };
    private bool IsLoading = true;
    
    // Sample flows - in production this would come from API
    private List<FlowItem> FlowsList = new();
    
    protected override async Task OnInitializedAsync()
    {
        InitializePalettes();
        await LoadFlows();
        
        // Load flow definition after flows are loaded
        if (FlowId != Guid.Empty)
        {
            var flow = FlowsList.FirstOrDefault(f => f.Id == FlowId);
            if (flow != null)
            {
                CurrentFlow = flow;
                LoadFlowDefinition(flow);
            }
        }
    }
    
    protected override void OnParametersSet()
    {
        // Only handle parameter changes after initial load
        if (FlowsList.Count > 0 && FlowId != Guid.Empty)
        {
            var flow = FlowsList.FirstOrDefault(f => f.Id == FlowId);
            if (flow != null && CurrentFlow.Id != flow.Id)
            {
                CurrentFlow = flow;
                LoadFlowDefinition(flow);
            }
        }
    }
    
    private bool _firstRender = true;
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_firstRender && FlowId != Guid.Empty && Diagram != null)
        {
            _firstRender = false;
            // Force diagram to refresh connectors after first render
            await Task.Delay(100);
            StateHasChanged();
        }
    }
    
    private async Task LoadFlows()
    {
        IsLoading = true;
        
        // Simulate API call - in production, use HttpClient to fetch from backend
        await Task.Delay(100);
        
        FlowsList = new List<FlowItem>
        {
            new() { 
                Id = Guid.Parse("11111111-1111-1111-1111-111111111111"), 
                Name = "Temperature Monitor", 
                Description = "Monitors tank temperatures and triggers alarms", 
                Deployed = true, 
                UpdatedAt = DateTime.Now.AddHours(-2),
                Definition = @"{""nodes"":[{""id"":""trigger-1"",""x"":100,""y"":100,""type"":""trigger-manual""},{""id"":""tag-1"",""x"":300,""y"":100,""type"":""tag-input""}],""connectors"":[{""sourceId"":""trigger-1"",""targetId"":""tag-1""}]}"
            },
            new() { 
                Id = Guid.Parse("22222222-2222-2222-2222-222222222222"), 
                Name = "Pressure Alarm", 
                Description = "Sends alerts when pressure exceeds threshold", 
                Deployed = false, 
                UpdatedAt = DateTime.Now.AddDays(-1),
                Definition = "{}"
            },
            new() { 
                Id = Guid.Parse("33333333-3333-3333-3333-333333333333"), 
                Name = "Data Logger", 
                Description = "Logs production data to database every 5 minutes", 
                Deployed = true, 
                UpdatedAt = DateTime.Now.AddMinutes(-30),
                Definition = "{}"
            },
            new() { 
                Id = Guid.Parse("44444444-4444-4444-4444-444444444444"), 
                Name = "Tank Level Controller", 
                Description = "Maintains tank levels within specified range", 
                Deployed = true, 
                UpdatedAt = DateTime.Now.AddHours(-6),
                Definition = "{}"
            },
            new() { 
                Id = Guid.Parse("55555555-5555-5555-5555-555555555555"), 
                Name = "Batch Report Generator", 
                Description = "Generates production reports at end of shift", 
                Deployed = false, 
                UpdatedAt = DateTime.Now.AddDays(-3),
                Definition = "{}"
            }
        };
        
        IsLoading = false;
    }
    
    private void LoadFlowDefinition(FlowItem flow)
    {
        // Load existing nodes from flow definition
        // This would parse the JSON definition and create nodes/connectors
        if (!string.IsNullOrEmpty(flow.Definition) && flow.Definition != "{}")
        {
            // For demo, add some sample nodes for the Temperature Monitor flow
            if (flow.Name == "Temperature Monitor")
            {
                Nodes = new DiagramObjectCollection<Node>
                {
                    CreateFlowNode("trigger-manual-1", "Manual Trigger", "#4caf50", 150, 150, 0, 1),
                    CreateFlowNode("tag-input-1", "Tag Input", "#2196f3", 350, 150, 1, 1),
                    CreateFlowNode("compare-greater-1", "Greater Than", "#607d8b", 550, 150, 2, 1),
                    CreateFlowNode("notification-1", "Notification", "#e91e63", 750, 150, 1, 0)
                };
                
                Connectors = new DiagramObjectCollection<Connector>
                {
                    CreateFlowConnector("conn-1", "trigger-manual-1", "output-0", "tag-input-1", "input-0"),
                    CreateFlowConnector("conn-2", "tag-input-1", "output-0", "compare-greater-1", "input-0"),
                    CreateFlowConnector("conn-3", "compare-greater-1", "output-0", "notification-1", "input-0")
                };
            }
        }
    }
    
    /// <summary>
    /// Creates a flow node with proper ports (input/output handles) similar to the original React app
    /// </summary>
    private Node CreateFlowNode(string id, string label, string color, double x, double y, int inputCount, int outputCount)
    {
        var node = new Node
        {
            ID = id,
            OffsetX = x,
            OffsetY = y,
            Width = 140,
            Height = 70,
            Shape = new BasicShape { Type = NodeShapes.Basic, Shape = NodeBasicShapes.Rectangle, CornerRadius = 8 },
            Style = new ShapeStyle { Fill = color, StrokeColor = "#ffffff", StrokeWidth = 2 },
            Annotations = new DiagramObjectCollection<ShapeAnnotation>
            {
                new ShapeAnnotation 
                { 
                    Content = label, 
                    Style = new TextStyle { Color = "#ffffff", FontSize = 12, Bold = true },
                    Offset = new DiagramPoint { X = 0.5, Y = 0.5 }
                }
            },
            Ports = new DiagramObjectCollection<PointPort>()
        };
        
        // Add input ports (left side)
        for (int i = 0; i < inputCount; i++)
        {
            var yOffset = inputCount == 1 ? 0.5 : (i + 1.0) / (inputCount + 1);
            node.Ports.Add(new PointPort
            {
                ID = $"input-{i}",
                Offset = new DiagramPoint { X = 0, Y = yOffset },
                Visibility = PortVisibility.Visible,
                Shape = PortShapes.Circle,
                Width = 12,
                Height = 12,
                Style = new ShapeStyle { Fill = "#2196f3", StrokeColor = "#ffffff", StrokeWidth = 2 },
                Constraints = PortConstraints.Default | PortConstraints.Draw
            });
        }
        
        // Add output ports (right side)
        for (int i = 0; i < outputCount; i++)
        {
            var yOffset = outputCount == 1 ? 0.5 : (i + 1.0) / (outputCount + 1);
            node.Ports.Add(new PointPort
            {
                ID = $"output-{i}",
                Offset = new DiagramPoint { X = 1, Y = yOffset },
                Visibility = PortVisibility.Visible,
                Shape = PortShapes.Circle,
                Width = 12,
                Height = 12,
                Style = new ShapeStyle { Fill = "#ff9800", StrokeColor = "#ffffff", StrokeWidth = 2 },
                Constraints = PortConstraints.Default | PortConstraints.Draw
            });
        }
        
        return node;
    }
    
    /// <summary>
    /// Creates a connector between two ports
    /// </summary>
    private Connector CreateFlowConnector(string id, string sourceId, string sourcePort, string targetId, string targetPort)
    {
        return new Connector
        {
            ID = id,
            SourceID = sourceId,
            SourcePortID = sourcePort,
            TargetID = targetId,
            TargetPortID = targetPort,
            Type = ConnectorSegmentType.Orthogonal,
            Style = new ShapeStyle { StrokeColor = "#4caf50", StrokeWidth = 2 },
            TargetDecorator = new DecoratorSettings 
            { 
                Shape = DecoratorShape.Arrow, 
                Style = new ShapeStyle { Fill = "#4caf50", StrokeColor = "#4caf50" },
                Width = 10,
                Height = 10
            },
            CornerRadius = 5
        };
    }
    
    private void InitializePalettes()
    {
        // Triggers palette - output only nodes
        var triggerNodes = new DiagramObjectCollection<NodeBase>
        {
            CreatePaletteNode("trigger-manual", "Manual Trigger", "#4caf50", 0, 1),
            CreatePaletteNode("trigger-schedule", "Schedule", "#4caf50", 0, 1),
            CreatePaletteNode("trigger-tag", "Tag Change", "#4caf50", 0, 1)
        };
        
        // Tag Operations palette - input and output
        var tagNodes = new DiagramObjectCollection<NodeBase>
        {
            CreatePaletteNode("tag-input", "Tag Input", "#2196f3", 1, 1),
            CreatePaletteNode("tag-output", "Tag Output", "#ff9800", 1, 0),
            CreatePaletteNode("tag-write", "Tag Write", "#ff5722", 1, 0)
        };
        
        // Math palette - multiple inputs, single output
        var mathNodes = new DiagramObjectCollection<NodeBase>
        {
            CreatePaletteNode("math-add", "Add (+)", "#9c27b0", 2, 1),
            CreatePaletteNode("math-subtract", "Subtract (-)", "#9c27b0", 2, 1),
            CreatePaletteNode("math-multiply", "Multiply (ร)", "#9c27b0", 2, 1),
            CreatePaletteNode("math-divide", "Divide (รท)", "#9c27b0", 2, 1)
        };
        
        // Logic palette - comparison and conditionals
        var logicNodes = new DiagramObjectCollection<NodeBase>
        {
            CreatePaletteNode("logic-if", "If/Else", "#795548", 1, 2),
            CreatePaletteNode("compare-equal", "Equal (==)", "#607d8b", 2, 1),
            CreatePaletteNode("compare-greater", "Greater (>)", "#607d8b", 2, 1),
            CreatePaletteNode("compare-less", "Less (<)", "#607d8b", 2, 1)
        };
        
        // Output palette - input only nodes
        var outputNodes = new DiagramObjectCollection<NodeBase>
        {
            CreatePaletteNode("debug-log", "Debug Log", "#f44336", 1, 0),
            CreatePaletteNode("notification", "Notification", "#e91e63", 1, 0),
            CreatePaletteNode("database-write", "DB Write", "#3f51b5", 1, 0)
        };
        
        Palettes = new DiagramObjectCollection<Palette>
        {
            new Palette { Title = "Triggers", Symbols = triggerNodes, IsExpanded = true },
            new Palette { Title = "Tag Operations", Symbols = tagNodes, IsExpanded = true },
            new Palette { Title = "Math", Symbols = mathNodes, IsExpanded = false },
            new Palette { Title = "Logic", Symbols = logicNodes, IsExpanded = false },
            new Palette { Title = "Output", Symbols = outputNodes, IsExpanded = false }
        };
    }
    
    private Node CreatePaletteNode(string id, string label, string color, int inputCount, int outputCount)
    {
        var node = new Node
        {
            ID = id,
            Width = 100,
            Height = 50,
            Shape = new BasicShape { Type = NodeShapes.Basic, Shape = NodeBasicShapes.Rectangle, CornerRadius = 6 },
            Style = new ShapeStyle { Fill = color, StrokeColor = "#ffffff", StrokeWidth = 2 },
            Annotations = new DiagramObjectCollection<ShapeAnnotation>
            {
                new ShapeAnnotation
                {
                    Content = label,
                    Style = new TextStyle { Color = "#ffffff", FontSize = 10, Bold = true }
                }
            },
            Ports = new DiagramObjectCollection<PointPort>()
        };
        
        // Add input ports (left side) - visible circles
        for (int i = 0; i < inputCount; i++)
        {
            var yOffset = inputCount == 1 ? 0.5 : (i + 1.0) / (inputCount + 1);
            node.Ports.Add(new PointPort
            {
                ID = $"input-{i}",
                Offset = new DiagramPoint { X = 0, Y = yOffset },
                Visibility = PortVisibility.Visible,
                Shape = PortShapes.Circle,
                Width = 10,
                Height = 10,
                Style = new ShapeStyle { Fill = "#2196f3", StrokeColor = "#ffffff", StrokeWidth = 2 },
                Constraints = PortConstraints.Default | PortConstraints.Draw
            });
        }
        
        // Add output ports (right side) - visible circles
        for (int i = 0; i < outputCount; i++)
        {
            var yOffset = outputCount == 1 ? 0.5 : (i + 1.0) / (outputCount + 1);
            node.Ports.Add(new PointPort
            {
                ID = $"output-{i}",
                Offset = new DiagramPoint { X = 1, Y = yOffset },
                Visibility = PortVisibility.Visible,
                Shape = PortShapes.Circle,
                Width = 10,
                Height = 10,
                Style = new ShapeStyle { Fill = "#ff9800", StrokeColor = "#ffffff", StrokeWidth = 2 },
                Constraints = PortConstraints.Default | PortConstraints.Draw
            });
        }
        
        return node;
    }
    
    private SymbolInfo GetSymbolInfo(IDiagramObject symbol)
    {
        if (symbol is Node node)
        {
            return new SymbolInfo
            {
                Fit = true,
                Description = new SymbolDescription { Text = node.ID ?? "" }
            };
        }
        return new SymbolInfo { Fit = true };
    }
    
    private void CreateNewFlow()
    {
        Navigation.NavigateTo($"/flows/{Guid.NewGuid()}");
    }
    
    private void EditFlow(Guid id)
    {
        Navigation.NavigateTo($"/flows/{id}");
    }
    
    private void DeleteFlow(Guid id)
    {
        FlowsList.RemoveAll(f => f.Id == id);
    }
    
    private void GoBack()
    {
        Navigation.NavigateTo("/flows");
    }
    
    private void ToggleDeploy()
    {
        CurrentFlow.Deployed = !CurrentFlow.Deployed;
    }
    
    private async Task SaveFlow()
    {
        // Save flow to backend - serialize nodes and connectors
        if (Diagram != null)
        {
            // In production, serialize the diagram and send to API
            CurrentFlow.UpdatedAt = DateTime.Now;
            await Task.CompletedTask;
        }
    }
    
    private void OnNodeCreating(IDiagramObject obj)
    {
        if (obj is Node node)
        {
            // Set proper size for dropped nodes
            node.Width = 140;
            node.Height = 70;
            
            // Generate unique ID if not already an instance
            if (node.ID != null && !node.ID.Contains("-instance-"))
            {
                node.ID = $"{node.ID}-instance-{Guid.NewGuid():N}";
            }
            
            // Ensure ports are visible and enabled for connections
            if (node.Ports != null)
            {
                foreach (var port in node.Ports)
                {
                    port.Visibility = PortVisibility.Visible;
                    port.Constraints = PortConstraints.Default | PortConstraints.Draw;
                }
            }
        }
    }
    
    private void OnConnectorCreating(IDiagramObject obj)
    {
        if (obj is Connector connector)
        {
            connector.Type = ConnectorSegmentType.Orthogonal;
            connector.Style = new ShapeStyle { StrokeColor = "#4caf50", StrokeWidth = 2 };
            connector.CornerRadius = 5;
            connector.TargetDecorator = new DecoratorSettings 
            { 
                Shape = DecoratorShape.Arrow,
                Width = 10,
                Height = 10,
                Style = new ShapeStyle { Fill = "#4caf50", StrokeColor = "#4caf50" } 
            };
        }
    }
    
    private void OnDragDrop(DropEventArgs args)
    {
        // Handle node drop from palette - this fires after NodeCreating
        if (args.Element is Node node)
        {
            // Generate unique ID for the dropped node if not done already
            var baseId = node.ID?.Split("-instance-").FirstOrDefault() ?? "node";
            if (!node.ID!.Contains("-instance-"))
            {
                node.ID = $"{baseId}-instance-{Guid.NewGuid():N}";
            }
            
            // Ensure ports are visible after drop
            if (node.Ports != null)
            {
                foreach (var port in node.Ports)
                {
                    port.Visibility = PortVisibility.Visible;
                    port.Width = 12;
                    port.Height = 12;
                }
            }
        }
    }
    
    private void OnSelectionChanged(Syncfusion.Blazor.Diagram.SelectionChangedEventArgs args)
    {
        // Get selected nodes from the diagram
        if (Diagram?.SelectionSettings?.Nodes?.Count > 0)
        {
            SelectedNode = Diagram.SelectionSettings.Nodes[0] as Node;
            if (SelectedNode?.Annotations?.Count > 0)
            {
                SelectedNodeLabel = SelectedNode.Annotations[0].Content ?? "";
            }
        }
        else
        {
            SelectedNode = null;
            SelectedNodeLabel = "";
        }
    }
    
    private string GetNodeType(Node node)
    {
        var id = node.ID ?? "";
        var parts = id.Split("-instance-").FirstOrDefault()?.Split('-') ?? Array.Empty<string>();
        return string.Join(" ", parts.Take(2)).ToUpper();
    }
    
    class FlowItem
    {
        public Guid Id { get; set; }
        public string Name { get; set; } = "";
        public string Description { get; set; } = "";
        public bool Deployed { get; set; }
        public string Status => Deployed ? "Deployed" : "Stopped";
        public DateTime UpdatedAt { get; set; }
        public string Definition { get; set; } = "{}";
    }
}
